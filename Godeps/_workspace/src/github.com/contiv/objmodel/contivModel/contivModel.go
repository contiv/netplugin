// contivModel.go
// This file is auto generated by modelgen tool
// Do not edit this file manually

package contivModel

import (
	"encoding/json"
	"errors"
	log "github.com/Sirupsen/logrus"
	"github.com/contiv/objmodel/objdb/modeldb"
	"github.com/gorilla/mux"
	"net/http"
	"regexp"
)

type HttpApiFunc func(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error)
type App struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	AppName    string `json:"appName,omitempty"`
	TenantName string `json:"tenantName,omitempty"`

	// add link-sets and links
	LinkSets AppLinkSets `json:"link-sets,omitempty"`
	Links    AppLinks    `json:"links,omitempty"`
}

type AppLinkSets struct {
	Services map[string]modeldb.Link `json:"Services,omitempty"`
}

type AppLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type EndpointGroup struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	EndpointGroupID int      `json:"endpointGroupId,omitempty"`
	GroupName       string   `json:"groupName,omitempty"`
	NetworkName     string   `json:"networkName,omitempty"`
	Policies        []string `json:"policies,omitempty"`
	TenantName      string   `json:"tenantName,omitempty"`

	// add link-sets and links
	LinkSets EndpointGroupLinkSets `json:"link-sets,omitempty"`
	Links    EndpointGroupLinks    `json:"links,omitempty"`
}

type EndpointGroupLinkSets struct {
	Policies map[string]modeldb.Link `json:"Policies,omitempty"`
	Services map[string]modeldb.Link `json:"Services,omitempty"`
}

type EndpointGroupLinks struct {
	Network modeldb.Link `json:"Network,omitempty"`
	Tenant  modeldb.Link `json:"Tenant,omitempty"`
}

type Global struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	Name             string `json:"name,omitempty"`
	NetworkInfraType string `json:"network-infra-type,omitempty"`
}

type Network struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	Encap       string `json:"encap,omitempty"`
	Gateway     string `json:"gateway,omitempty"`
	IsPrivate   bool   `json:"isPrivate,omitempty"`
	IsPublic    bool   `json:"isPublic,omitempty"`
	NetworkName string `json:"networkName,omitempty"`
	PktTag      int    `json:"pktTag,omitempty"`
	Subnet      string `json:"subnet,omitempty"`
	TenantName  string `json:"tenantName,omitempty"`

	// add link-sets and links
	LinkSets NetworkLinkSets `json:"link-sets,omitempty"`
	Links    NetworkLinks    `json:"links,omitempty"`
}

type NetworkLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`
	Services       map[string]modeldb.Link `json:"Services,omitempty"`
}

type NetworkLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type Policy struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	PolicyName string `json:"policyName,omitempty"`
	TenantName string `json:"tenantName,omitempty"`

	// add link-sets and links
	LinkSets PolicyLinkSets `json:"link-sets,omitempty"`
	Links    PolicyLinks    `json:"links,omitempty"`
}

type PolicyLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`
	Rules          map[string]modeldb.Link `json:"Rules,omitempty"`
}

type PolicyLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type Rule struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	Action        string `json:"action,omitempty"`
	Direction     string `json:"direction,omitempty"`
	EndpointGroup string `json:"endpointGroup,omitempty"`
	IpAddress     string `json:"ipAddress,omitempty"`
	Network       string `json:"network,omitempty"`
	PolicyName    string `json:"policyName,omitempty"`
	Port          int    `json:"port,omitempty"`
	Priority      int    `json:"priority,omitempty"`
	Protocol      string `json:"protocol,omitempty"`
	RuleID        string `json:"ruleId,omitempty"`
	TenantName    string `json:"tenantName,omitempty"`

	// add link-sets and links
	LinkSets RuleLinkSets `json:"link-sets,omitempty"`
}

type RuleLinkSets struct {
	Policies map[string]modeldb.Link `json:"Policies,omitempty"`
}

type Service struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	AppName        string   `json:"appName,omitempty"`
	Command        string   `json:"command,omitempty"`
	Cpu            string   `json:"cpu,omitempty"`
	EndpointGroups []string `json:"endpointGroups,omitempty"`
	Environment    []string `json:"environment,omitempty"`
	ImageName      string   `json:"imageName,omitempty"`
	Memory         string   `json:"memory,omitempty"`
	Networks       []string `json:"networks,omitempty"`
	Scale          int      `json:"scale,omitempty"`
	ServiceName    string   `json:"serviceName,omitempty"`
	TenantName     string   `json:"tenantName,omitempty"`
	VolumeProfile  string   `json:"volumeProfile,omitempty"`

	// add link-sets and links
	LinkSets ServiceLinkSets `json:"link-sets,omitempty"`
	Links    ServiceLinks    `json:"links,omitempty"`
}

type ServiceLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`
	Instances      map[string]modeldb.Link `json:"Instances,omitempty"`
	Networks       map[string]modeldb.Link `json:"Networks,omitempty"`
}

type ServiceLinks struct {
	App           modeldb.Link `json:"App,omitempty"`
	VolumeProfile modeldb.Link `json:"VolumeProfile,omitempty"`
}

type ServiceInstance struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	AppName     string   `json:"appName,omitempty"`
	InstanceID  string   `json:"instanceId,omitempty"`
	ServiceName string   `json:"serviceName,omitempty"`
	TenantName  string   `json:"tenantName,omitempty"`
	Volumes     []string `json:"volumes,omitempty"`

	// add link-sets and links
	LinkSets ServiceInstanceLinkSets `json:"link-sets,omitempty"`
	Links    ServiceInstanceLinks    `json:"links,omitempty"`
}

type ServiceInstanceLinkSets struct {
	Volumes map[string]modeldb.Link `json:"Volumes,omitempty"`
}

type ServiceInstanceLinks struct {
	Service modeldb.Link `json:"Service,omitempty"`
}

type Tenant struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	DefaultNetwork string `json:"defaultNetwork,omitempty"`
	SubnetLen      int    `json:"subnetLen,omitempty"`
	SubnetPool     string `json:"subnetPool,omitempty"`
	TenantName     string `json:"tenantName,omitempty"`
	Vlans          string `json:"vlans,omitempty"`
	Vxlans         string `json:"vxlans,omitempty"`

	// add link-sets and links
	LinkSets TenantLinkSets `json:"link-sets,omitempty"`
}

type TenantLinkSets struct {
	Apps           map[string]modeldb.Link `json:"Apps,omitempty"`
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`
	Networks       map[string]modeldb.Link `json:"Networks,omitempty"`
	Policies       map[string]modeldb.Link `json:"Policies,omitempty"`
	VolumeProfiles map[string]modeldb.Link `json:"VolumeProfiles,omitempty"`
	Volumes        map[string]modeldb.Link `json:"Volumes,omitempty"`
}

type Volume struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	DatastoreType string `json:"datastoreType,omitempty"`
	MountPoint    string `json:"mountPoint,omitempty"`
	PoolName      string `json:"poolName,omitempty"`
	Size          string `json:"size,omitempty"`
	TenantName    string `json:"tenantName,omitempty"`
	VolumeName    string `json:"volumeName,omitempty"`

	// add link-sets and links
	LinkSets VolumeLinkSets `json:"link-sets,omitempty"`
	Links    VolumeLinks    `json:"links,omitempty"`
}

type VolumeLinkSets struct {
	ServiceInstances map[string]modeldb.Link `json:"ServiceInstances,omitempty"`
}

type VolumeLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type VolumeProfile struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	DatastoreType     string `json:"datastoreType,omitempty"`
	MountPoint        string `json:"mountPoint,omitempty"`
	PoolName          string `json:"poolName,omitempty"`
	Size              string `json:"size,omitempty"`
	TenantName        string `json:"tenantName,omitempty"`
	VolumeProfileName string `json:"volumeProfileName,omitempty"`

	// add link-sets and links
	LinkSets VolumeProfileLinkSets `json:"link-sets,omitempty"`
	Links    VolumeProfileLinks    `json:"links,omitempty"`
}

type VolumeProfileLinkSets struct {
	Services map[string]modeldb.Link `json:"Services,omitempty"`
}

type VolumeProfileLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type Collections struct {
	apps             map[string]*App
	endpointGroups   map[string]*EndpointGroup
	globals          map[string]*Global
	networks         map[string]*Network
	policys          map[string]*Policy
	rules            map[string]*Rule
	services         map[string]*Service
	serviceInstances map[string]*ServiceInstance
	tenants          map[string]*Tenant
	volumes          map[string]*Volume
	volumeProfiles   map[string]*VolumeProfile
}

var collections Collections

type AppCallbacks interface {
	AppCreate(app *App) error
	AppUpdate(app, params *App) error
	AppDelete(app *App) error
}

type EndpointGroupCallbacks interface {
	EndpointGroupCreate(endpointGroup *EndpointGroup) error
	EndpointGroupUpdate(endpointGroup, params *EndpointGroup) error
	EndpointGroupDelete(endpointGroup *EndpointGroup) error
}

type GlobalCallbacks interface {
	GlobalCreate(global *Global) error
	GlobalUpdate(global, params *Global) error
	GlobalDelete(global *Global) error
}

type NetworkCallbacks interface {
	NetworkCreate(network *Network) error
	NetworkUpdate(network, params *Network) error
	NetworkDelete(network *Network) error
}

type PolicyCallbacks interface {
	PolicyCreate(policy *Policy) error
	PolicyUpdate(policy, params *Policy) error
	PolicyDelete(policy *Policy) error
}

type RuleCallbacks interface {
	RuleCreate(rule *Rule) error
	RuleUpdate(rule, params *Rule) error
	RuleDelete(rule *Rule) error
}

type ServiceCallbacks interface {
	ServiceCreate(service *Service) error
	ServiceUpdate(service, params *Service) error
	ServiceDelete(service *Service) error
}

type ServiceInstanceCallbacks interface {
	ServiceInstanceCreate(serviceInstance *ServiceInstance) error
	ServiceInstanceUpdate(serviceInstance, params *ServiceInstance) error
	ServiceInstanceDelete(serviceInstance *ServiceInstance) error
}

type TenantCallbacks interface {
	TenantCreate(tenant *Tenant) error
	TenantUpdate(tenant, params *Tenant) error
	TenantDelete(tenant *Tenant) error
}

type VolumeCallbacks interface {
	VolumeCreate(volume *Volume) error
	VolumeUpdate(volume, params *Volume) error
	VolumeDelete(volume *Volume) error
}

type VolumeProfileCallbacks interface {
	VolumeProfileCreate(volumeProfile *VolumeProfile) error
	VolumeProfileUpdate(volumeProfile, params *VolumeProfile) error
	VolumeProfileDelete(volumeProfile *VolumeProfile) error
}

type CallbackHandlers struct {
	AppCb             AppCallbacks
	EndpointGroupCb   EndpointGroupCallbacks
	GlobalCb          GlobalCallbacks
	NetworkCb         NetworkCallbacks
	PolicyCb          PolicyCallbacks
	RuleCb            RuleCallbacks
	ServiceCb         ServiceCallbacks
	ServiceInstanceCb ServiceInstanceCallbacks
	TenantCb          TenantCallbacks
	VolumeCb          VolumeCallbacks
	VolumeProfileCb   VolumeProfileCallbacks
}

var objCallbackHandler CallbackHandlers

func Init() {
	collections.apps = make(map[string]*App)
	collections.endpointGroups = make(map[string]*EndpointGroup)
	collections.globals = make(map[string]*Global)
	collections.networks = make(map[string]*Network)
	collections.policys = make(map[string]*Policy)
	collections.rules = make(map[string]*Rule)
	collections.services = make(map[string]*Service)
	collections.serviceInstances = make(map[string]*ServiceInstance)
	collections.tenants = make(map[string]*Tenant)
	collections.volumes = make(map[string]*Volume)
	collections.volumeProfiles = make(map[string]*VolumeProfile)

	restoreApp()
	restoreEndpointGroup()
	restoreGlobal()
	restoreNetwork()
	restorePolicy()
	restoreRule()
	restoreService()
	restoreServiceInstance()
	restoreTenant()
	restoreVolume()
	restoreVolumeProfile()

}

func RegisterAppCallbacks(handler AppCallbacks) {
	objCallbackHandler.AppCb = handler
}

func RegisterEndpointGroupCallbacks(handler EndpointGroupCallbacks) {
	objCallbackHandler.EndpointGroupCb = handler
}

func RegisterGlobalCallbacks(handler GlobalCallbacks) {
	objCallbackHandler.GlobalCb = handler
}

func RegisterNetworkCallbacks(handler NetworkCallbacks) {
	objCallbackHandler.NetworkCb = handler
}

func RegisterPolicyCallbacks(handler PolicyCallbacks) {
	objCallbackHandler.PolicyCb = handler
}

func RegisterRuleCallbacks(handler RuleCallbacks) {
	objCallbackHandler.RuleCb = handler
}

func RegisterServiceCallbacks(handler ServiceCallbacks) {
	objCallbackHandler.ServiceCb = handler
}

func RegisterServiceInstanceCallbacks(handler ServiceInstanceCallbacks) {
	objCallbackHandler.ServiceInstanceCb = handler
}

func RegisterTenantCallbacks(handler TenantCallbacks) {
	objCallbackHandler.TenantCb = handler
}

func RegisterVolumeCallbacks(handler VolumeCallbacks) {
	objCallbackHandler.VolumeCb = handler
}

func RegisterVolumeProfileCallbacks(handler VolumeProfileCallbacks) {
	objCallbackHandler.VolumeProfileCb = handler
}

// Simple Wrapper for http handlers
func makeHttpHandler(handlerFunc HttpApiFunc) http.HandlerFunc {
	// Create a closure and return an anonymous function
	return func(w http.ResponseWriter, r *http.Request) {
		// Call the handler
		resp, err := handlerFunc(w, r, mux.Vars(r))
		if err != nil {
			// Log error
			log.Errorf("Handler for %s %s returned error: %s", r.Method, r.URL, err)

			// Send HTTP response
			http.Error(w, err.Error(), http.StatusInternalServerError)
		} else {
			// Send HTTP response as Json
			err = writeJSON(w, http.StatusOK, resp)
			if err != nil {
				log.Errorf("Error generating json. Err: %v", err)
			}
		}
	}
}

// writeJSON: writes the value v to the http response stream as json with standard
// json encoding.
func writeJSON(w http.ResponseWriter, code int, v interface{}) error {
	// Set content type as json
	w.Header().Set("Content-Type", "application/json")

	// write the HTTP status code
	w.WriteHeader(code)

	// Write the Json output
	return json.NewEncoder(w).Encode(v)
}

// Add all routes for REST handlers
func AddRoutes(router *mux.Router) {
	var route, listRoute string

	// Register app
	route = "/api/apps/{key}/"
	listRoute = "/api/apps/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListApps))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetApp))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateApp))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateApp))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteApp))

	// Register endpointGroup
	route = "/api/endpointGroups/{key}/"
	listRoute = "/api/endpointGroups/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListEndpointGroups))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetEndpointGroup))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateEndpointGroup))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateEndpointGroup))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteEndpointGroup))

	// Register global
	route = "/api/globals/{key}/"
	listRoute = "/api/globals/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListGlobals))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetGlobal))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateGlobal))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateGlobal))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteGlobal))

	// Register network
	route = "/api/networks/{key}/"
	listRoute = "/api/networks/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListNetworks))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetNetwork))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateNetwork))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateNetwork))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteNetwork))

	// Register policy
	route = "/api/policys/{key}/"
	listRoute = "/api/policys/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListPolicys))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetPolicy))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreatePolicy))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreatePolicy))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeletePolicy))

	// Register rule
	route = "/api/rules/{key}/"
	listRoute = "/api/rules/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListRules))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetRule))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateRule))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateRule))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteRule))

	// Register service
	route = "/api/services/{key}/"
	listRoute = "/api/services/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListServices))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetService))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateService))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateService))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteService))

	// Register serviceInstance
	route = "/api/serviceInstances/{key}/"
	listRoute = "/api/serviceInstances/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListServiceInstances))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetServiceInstance))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateServiceInstance))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateServiceInstance))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteServiceInstance))

	// Register tenant
	route = "/api/tenants/{key}/"
	listRoute = "/api/tenants/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListTenants))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetTenant))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateTenant))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateTenant))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteTenant))

	// Register volume
	route = "/api/volumes/{key}/"
	listRoute = "/api/volumes/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListVolumes))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetVolume))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateVolume))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateVolume))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteVolume))

	// Register volumeProfile
	route = "/api/volumeProfiles/{key}/"
	listRoute = "/api/volumeProfiles/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListVolumeProfiles))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetVolumeProfile))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateVolumeProfile))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateVolumeProfile))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteVolumeProfile))

}

// LIST REST call
func httpListApps(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListApps: %+v", vars)

	list := make([]*App, 0)
	for _, obj := range collections.apps {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetApp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetApp: %+v", vars)

	key := vars["key"]

	obj := collections.apps[key]
	if obj == nil {
		log.Errorf("app %s not found", key)
		return nil, errors.New("app not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateApp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetApp: %+v", vars)

	var obj App
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding app create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateApp(&obj)
	if err != nil {
		log.Errorf("CreateApp error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteApp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteApp: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteApp(key)
	if err != nil {
		log.Errorf("DeleteApp error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a app object
func CreateApp(obj *App) error {
	// Validate parameters
	err := ValidateApp(obj)
	if err != nil {
		log.Errorf("ValidateApp retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.AppCb == nil {
		log.Errorf("No callback registered for app object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.apps[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.AppCb.AppUpdate(collections.apps[obj.Key], obj)
		if err != nil {
			log.Errorf("AppUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.apps[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.AppCb.AppCreate(obj)
		if err != nil {
			log.Errorf("AppCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.apps, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving app %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to app from collection
func FindApp(key string) *App {
	obj := collections.apps[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a app object
func DeleteApp(key string) error {
	obj := collections.apps[key]
	if obj == nil {
		log.Errorf("app %s not found", key)
		return errors.New("app not found")
	}

	// Check if we handle this object
	if objCallbackHandler.AppCb == nil {
		log.Errorf("No callback registered for app object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.AppCb.AppDelete(obj)
	if err != nil {
		log.Errorf("AppDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting app %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.apps, key)

	return nil
}

func (self *App) GetType() string {
	return "app"
}

func (self *App) GetKey() string {
	return self.Key
}

func (self *App) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read app object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("app", self.Key, self)
}

func (self *App) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write app object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("app", self.Key, self)
}

func (self *App) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete app object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("app", self.Key)
}

func restoreApp() error {
	strList, err := modeldb.ReadAllObj("app")
	if err != nil {
		log.Errorf("Error reading app list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var app App
		err = json.Unmarshal([]byte(objStr), &app)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.apps[app.Key] = &app
	}

	return nil
}

// Validate a app object
func ValidateApp(obj *App) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.AppName
	if obj.Key != keyStr {
		log.Errorf("Expecting App Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}

// LIST REST call
func httpListEndpointGroups(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListEndpointGroups: %+v", vars)

	list := make([]*EndpointGroup, 0)
	for _, obj := range collections.endpointGroups {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetEndpointGroup: %+v", vars)

	key := vars["key"]

	obj := collections.endpointGroups[key]
	if obj == nil {
		log.Errorf("endpointGroup %s not found", key)
		return nil, errors.New("endpointGroup not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetEndpointGroup: %+v", vars)

	var obj EndpointGroup
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding endpointGroup create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateEndpointGroup(&obj)
	if err != nil {
		log.Errorf("CreateEndpointGroup error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteEndpointGroup: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteEndpointGroup(key)
	if err != nil {
		log.Errorf("DeleteEndpointGroup error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a endpointGroup object
func CreateEndpointGroup(obj *EndpointGroup) error {
	// Validate parameters
	err := ValidateEndpointGroup(obj)
	if err != nil {
		log.Errorf("ValidateEndpointGroup retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.EndpointGroupCb == nil {
		log.Errorf("No callback registered for endpointGroup object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.endpointGroups[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.EndpointGroupCb.EndpointGroupUpdate(collections.endpointGroups[obj.Key], obj)
		if err != nil {
			log.Errorf("EndpointGroupUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.endpointGroups[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.EndpointGroupCb.EndpointGroupCreate(obj)
		if err != nil {
			log.Errorf("EndpointGroupCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.endpointGroups, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving endpointGroup %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to endpointGroup from collection
func FindEndpointGroup(key string) *EndpointGroup {
	obj := collections.endpointGroups[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a endpointGroup object
func DeleteEndpointGroup(key string) error {
	obj := collections.endpointGroups[key]
	if obj == nil {
		log.Errorf("endpointGroup %s not found", key)
		return errors.New("endpointGroup not found")
	}

	// Check if we handle this object
	if objCallbackHandler.EndpointGroupCb == nil {
		log.Errorf("No callback registered for endpointGroup object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.EndpointGroupCb.EndpointGroupDelete(obj)
	if err != nil {
		log.Errorf("EndpointGroupDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting endpointGroup %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.endpointGroups, key)

	return nil
}

func (self *EndpointGroup) GetType() string {
	return "endpointGroup"
}

func (self *EndpointGroup) GetKey() string {
	return self.Key
}

func (self *EndpointGroup) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read endpointGroup object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("endpointGroup", self.Key, self)
}

func (self *EndpointGroup) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write endpointGroup object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("endpointGroup", self.Key, self)
}

func (self *EndpointGroup) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete endpointGroup object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("endpointGroup", self.Key)
}

func restoreEndpointGroup() error {
	strList, err := modeldb.ReadAllObj("endpointGroup")
	if err != nil {
		log.Errorf("Error reading endpointGroup list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var endpointGroup EndpointGroup
		err = json.Unmarshal([]byte(objStr), &endpointGroup)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.endpointGroups[endpointGroup.Key] = &endpointGroup
	}

	return nil
}

// Validate a endpointGroup object
func ValidateEndpointGroup(obj *EndpointGroup) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.NetworkName + ":" + obj.GroupName
	if obj.Key != keyStr {
		log.Errorf("Expecting EndpointGroup Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}

// LIST REST call
func httpListGlobals(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListGlobals: %+v", vars)

	list := make([]*Global, 0)
	for _, obj := range collections.globals {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetGlobal(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetGlobal: %+v", vars)

	key := vars["key"]

	obj := collections.globals[key]
	if obj == nil {
		log.Errorf("global %s not found", key)
		return nil, errors.New("global not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateGlobal(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetGlobal: %+v", vars)

	var obj Global
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding global create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateGlobal(&obj)
	if err != nil {
		log.Errorf("CreateGlobal error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteGlobal(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteGlobal: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteGlobal(key)
	if err != nil {
		log.Errorf("DeleteGlobal error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a global object
func CreateGlobal(obj *Global) error {
	// Validate parameters
	err := ValidateGlobal(obj)
	if err != nil {
		log.Errorf("ValidateGlobal retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.GlobalCb == nil {
		log.Errorf("No callback registered for global object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.globals[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.GlobalCb.GlobalUpdate(collections.globals[obj.Key], obj)
		if err != nil {
			log.Errorf("GlobalUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.globals[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.GlobalCb.GlobalCreate(obj)
		if err != nil {
			log.Errorf("GlobalCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.globals, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving global %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to global from collection
func FindGlobal(key string) *Global {
	obj := collections.globals[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a global object
func DeleteGlobal(key string) error {
	obj := collections.globals[key]
	if obj == nil {
		log.Errorf("global %s not found", key)
		return errors.New("global not found")
	}

	// Check if we handle this object
	if objCallbackHandler.GlobalCb == nil {
		log.Errorf("No callback registered for global object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.GlobalCb.GlobalDelete(obj)
	if err != nil {
		log.Errorf("GlobalDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting global %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.globals, key)

	return nil
}

func (self *Global) GetType() string {
	return "global"
}

func (self *Global) GetKey() string {
	return self.Key
}

func (self *Global) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read global object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("global", self.Key, self)
}

func (self *Global) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write global object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("global", self.Key, self)
}

func (self *Global) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete global object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("global", self.Key)
}

func restoreGlobal() error {
	strList, err := modeldb.ReadAllObj("global")
	if err != nil {
		log.Errorf("Error reading global list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var global Global
		err = json.Unmarshal([]byte(objStr), &global)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.globals[global.Key] = &global
	}

	return nil
}

// Validate a global object
func ValidateGlobal(obj *Global) error {
	// Validate key is correct
	keyStr := obj.Name
	if obj.Key != keyStr {
		log.Errorf("Expecting Global Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.Name) > 64 {
		return errors.New("name string too long")
	}

	if len(obj.NetworkInfraType) > 64 {
		return errors.New("network-infra-type string too long")
	}

	return nil
}

// LIST REST call
func httpListNetworks(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListNetworks: %+v", vars)

	list := make([]*Network, 0)
	for _, obj := range collections.networks {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetwork: %+v", vars)

	key := vars["key"]

	obj := collections.networks[key]
	if obj == nil {
		log.Errorf("network %s not found", key)
		return nil, errors.New("network not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetwork: %+v", vars)

	var obj Network
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding network create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateNetwork(&obj)
	if err != nil {
		log.Errorf("CreateNetwork error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteNetwork: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteNetwork(key)
	if err != nil {
		log.Errorf("DeleteNetwork error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a network object
func CreateNetwork(obj *Network) error {
	// Validate parameters
	err := ValidateNetwork(obj)
	if err != nil {
		log.Errorf("ValidateNetwork retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.NetworkCb == nil {
		log.Errorf("No callback registered for network object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.networks[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.NetworkCb.NetworkUpdate(collections.networks[obj.Key], obj)
		if err != nil {
			log.Errorf("NetworkUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.networks[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.NetworkCb.NetworkCreate(obj)
		if err != nil {
			log.Errorf("NetworkCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.networks, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving network %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to network from collection
func FindNetwork(key string) *Network {
	obj := collections.networks[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a network object
func DeleteNetwork(key string) error {
	obj := collections.networks[key]
	if obj == nil {
		log.Errorf("network %s not found", key)
		return errors.New("network not found")
	}

	// Check if we handle this object
	if objCallbackHandler.NetworkCb == nil {
		log.Errorf("No callback registered for network object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.NetworkCb.NetworkDelete(obj)
	if err != nil {
		log.Errorf("NetworkDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting network %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.networks, key)

	return nil
}

func (self *Network) GetType() string {
	return "network"
}

func (self *Network) GetKey() string {
	return self.Key
}

func (self *Network) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read network object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("network", self.Key, self)
}

func (self *Network) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write network object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("network", self.Key, self)
}

func (self *Network) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete network object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("network", self.Key)
}

func restoreNetwork() error {
	strList, err := modeldb.ReadAllObj("network")
	if err != nil {
		log.Errorf("Error reading network list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var network Network
		err = json.Unmarshal([]byte(objStr), &network)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.networks[network.Key] = &network
	}

	return nil
}

// Validate a network object
func ValidateNetwork(obj *Network) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.NetworkName
	if obj.Key != keyStr {
		log.Errorf("Expecting Network Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	encapMatch := regexp.MustCompile("^(vlan|vxlan)$")
	if encapMatch.MatchString(obj.Encap) == false {
		return errors.New("encap string invalid format")
	}

	gatewayMatch := regexp.MustCompile("^([0-9]{1,3}?.[0-9]{1,3}?.[0-9]{1,3}?.[0-9]{1,3}?)$")
	if gatewayMatch.MatchString(obj.Gateway) == false {
	}

	if len(obj.NetworkName) > 64 {
		return errors.New("networkName string too long")
	}

	subnetMatch := regexp.MustCompile("^([0-9]{1,3}?.[0-9]{1,3}?.[0-9]{1,3}?.[0-9]{1,3}?/[0-9]{1,2}?)$")
	if subnetMatch.MatchString(obj.Subnet) == false {
		return errors.New("subnet string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	return nil
}

// LIST REST call
func httpListPolicys(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListPolicys: %+v", vars)

	list := make([]*Policy, 0)
	for _, obj := range collections.policys {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetPolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetPolicy: %+v", vars)

	key := vars["key"]

	obj := collections.policys[key]
	if obj == nil {
		log.Errorf("policy %s not found", key)
		return nil, errors.New("policy not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreatePolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetPolicy: %+v", vars)

	var obj Policy
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding policy create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreatePolicy(&obj)
	if err != nil {
		log.Errorf("CreatePolicy error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeletePolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeletePolicy: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeletePolicy(key)
	if err != nil {
		log.Errorf("DeletePolicy error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a policy object
func CreatePolicy(obj *Policy) error {
	// Validate parameters
	err := ValidatePolicy(obj)
	if err != nil {
		log.Errorf("ValidatePolicy retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.PolicyCb == nil {
		log.Errorf("No callback registered for policy object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.policys[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.PolicyCb.PolicyUpdate(collections.policys[obj.Key], obj)
		if err != nil {
			log.Errorf("PolicyUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.policys[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.PolicyCb.PolicyCreate(obj)
		if err != nil {
			log.Errorf("PolicyCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.policys, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving policy %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to policy from collection
func FindPolicy(key string) *Policy {
	obj := collections.policys[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a policy object
func DeletePolicy(key string) error {
	obj := collections.policys[key]
	if obj == nil {
		log.Errorf("policy %s not found", key)
		return errors.New("policy not found")
	}

	// Check if we handle this object
	if objCallbackHandler.PolicyCb == nil {
		log.Errorf("No callback registered for policy object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.PolicyCb.PolicyDelete(obj)
	if err != nil {
		log.Errorf("PolicyDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting policy %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.policys, key)

	return nil
}

func (self *Policy) GetType() string {
	return "policy"
}

func (self *Policy) GetKey() string {
	return self.Key
}

func (self *Policy) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read policy object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("policy", self.Key, self)
}

func (self *Policy) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write policy object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("policy", self.Key, self)
}

func (self *Policy) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete policy object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("policy", self.Key)
}

func restorePolicy() error {
	strList, err := modeldb.ReadAllObj("policy")
	if err != nil {
		log.Errorf("Error reading policy list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var policy Policy
		err = json.Unmarshal([]byte(objStr), &policy)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.policys[policy.Key] = &policy
	}

	return nil
}

// Validate a policy object
func ValidatePolicy(obj *Policy) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.PolicyName
	if obj.Key != keyStr {
		log.Errorf("Expecting Policy Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}

// LIST REST call
func httpListRules(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListRules: %+v", vars)

	list := make([]*Rule, 0)
	for _, obj := range collections.rules {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetRule(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetRule: %+v", vars)

	key := vars["key"]

	obj := collections.rules[key]
	if obj == nil {
		log.Errorf("rule %s not found", key)
		return nil, errors.New("rule not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateRule(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetRule: %+v", vars)

	var obj Rule
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding rule create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateRule(&obj)
	if err != nil {
		log.Errorf("CreateRule error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteRule(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteRule: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteRule(key)
	if err != nil {
		log.Errorf("DeleteRule error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a rule object
func CreateRule(obj *Rule) error {
	// Validate parameters
	err := ValidateRule(obj)
	if err != nil {
		log.Errorf("ValidateRule retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.RuleCb == nil {
		log.Errorf("No callback registered for rule object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.rules[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.RuleCb.RuleUpdate(collections.rules[obj.Key], obj)
		if err != nil {
			log.Errorf("RuleUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.rules[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.RuleCb.RuleCreate(obj)
		if err != nil {
			log.Errorf("RuleCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.rules, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving rule %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to rule from collection
func FindRule(key string) *Rule {
	obj := collections.rules[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a rule object
func DeleteRule(key string) error {
	obj := collections.rules[key]
	if obj == nil {
		log.Errorf("rule %s not found", key)
		return errors.New("rule not found")
	}

	// Check if we handle this object
	if objCallbackHandler.RuleCb == nil {
		log.Errorf("No callback registered for rule object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.RuleCb.RuleDelete(obj)
	if err != nil {
		log.Errorf("RuleDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting rule %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.rules, key)

	return nil
}

func (self *Rule) GetType() string {
	return "rule"
}

func (self *Rule) GetKey() string {
	return self.Key
}

func (self *Rule) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read rule object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("rule", self.Key, self)
}

func (self *Rule) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write rule object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("rule", self.Key, self)
}

func (self *Rule) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete rule object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("rule", self.Key)
}

func restoreRule() error {
	strList, err := modeldb.ReadAllObj("rule")
	if err != nil {
		log.Errorf("Error reading rule list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var rule Rule
		err = json.Unmarshal([]byte(objStr), &rule)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.rules[rule.Key] = &rule
	}

	return nil
}

// Validate a rule object
func ValidateRule(obj *Rule) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.PolicyName + ":" + obj.RuleID
	if obj.Key != keyStr {
		log.Errorf("Expecting Rule Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	actionMatch := regexp.MustCompile("^(accept|deny)$")
	if actionMatch.MatchString(obj.Action) == false {
		return errors.New("action string invalid format")
	}

	directionMatch := regexp.MustCompile("^(in|out|both)$")
	if directionMatch.MatchString(obj.Direction) == false {
		return errors.New("direction string invalid format")
	}

	if len(obj.EndpointGroup) > 64 {
		return errors.New("endpointGroup string too long")
	}

	if len(obj.Network) > 64 {
		return errors.New("network string too long")
	}

	if len(obj.PolicyName) > 64 {
		return errors.New("policyName string too long")
	}

	if obj.Port > 65535 {
		return errors.New("port Value Out of bound")
	}

	if obj.Priority == 0 {
		obj.Priority = 1
	}

	if obj.Priority < 1 {
		return errors.New("priority Value Out of bound")
	}

	if obj.Priority > 100 {
		return errors.New("priority Value Out of bound")
	}

	protocolMatch := regexp.MustCompile("^(tcp|udp|icmp||[0-9]{1,3}?)$")
	if protocolMatch.MatchString(obj.Protocol) == false {
		return errors.New("protocol string invalid format")
	}

	if len(obj.RuleID) > 64 {
		return errors.New("ruleId string too long")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	return nil
}

// LIST REST call
func httpListServices(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListServices: %+v", vars)

	list := make([]*Service, 0)
	for _, obj := range collections.services {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetService(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetService: %+v", vars)

	key := vars["key"]

	obj := collections.services[key]
	if obj == nil {
		log.Errorf("service %s not found", key)
		return nil, errors.New("service not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateService(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetService: %+v", vars)

	var obj Service
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding service create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateService(&obj)
	if err != nil {
		log.Errorf("CreateService error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteService(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteService: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteService(key)
	if err != nil {
		log.Errorf("DeleteService error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a service object
func CreateService(obj *Service) error {
	// Validate parameters
	err := ValidateService(obj)
	if err != nil {
		log.Errorf("ValidateService retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.ServiceCb == nil {
		log.Errorf("No callback registered for service object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.services[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.ServiceCb.ServiceUpdate(collections.services[obj.Key], obj)
		if err != nil {
			log.Errorf("ServiceUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.services[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.ServiceCb.ServiceCreate(obj)
		if err != nil {
			log.Errorf("ServiceCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.services, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving service %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to service from collection
func FindService(key string) *Service {
	obj := collections.services[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a service object
func DeleteService(key string) error {
	obj := collections.services[key]
	if obj == nil {
		log.Errorf("service %s not found", key)
		return errors.New("service not found")
	}

	// Check if we handle this object
	if objCallbackHandler.ServiceCb == nil {
		log.Errorf("No callback registered for service object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.ServiceCb.ServiceDelete(obj)
	if err != nil {
		log.Errorf("ServiceDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting service %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.services, key)

	return nil
}

func (self *Service) GetType() string {
	return "service"
}

func (self *Service) GetKey() string {
	return self.Key
}

func (self *Service) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read service object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("service", self.Key, self)
}

func (self *Service) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write service object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("service", self.Key, self)
}

func (self *Service) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete service object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("service", self.Key)
}

func restoreService() error {
	strList, err := modeldb.ReadAllObj("service")
	if err != nil {
		log.Errorf("Error reading service list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var service Service
		err = json.Unmarshal([]byte(objStr), &service)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.services[service.Key] = &service
	}

	return nil
}

// Validate a service object
func ValidateService(obj *Service) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.AppName + ":" + obj.ServiceName
	if obj.Key != keyStr {
		log.Errorf("Expecting Service Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}

// LIST REST call
func httpListServiceInstances(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListServiceInstances: %+v", vars)

	list := make([]*ServiceInstance, 0)
	for _, obj := range collections.serviceInstances {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetServiceInstance(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetServiceInstance: %+v", vars)

	key := vars["key"]

	obj := collections.serviceInstances[key]
	if obj == nil {
		log.Errorf("serviceInstance %s not found", key)
		return nil, errors.New("serviceInstance not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateServiceInstance(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetServiceInstance: %+v", vars)

	var obj ServiceInstance
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding serviceInstance create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateServiceInstance(&obj)
	if err != nil {
		log.Errorf("CreateServiceInstance error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteServiceInstance(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteServiceInstance: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteServiceInstance(key)
	if err != nil {
		log.Errorf("DeleteServiceInstance error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a serviceInstance object
func CreateServiceInstance(obj *ServiceInstance) error {
	// Validate parameters
	err := ValidateServiceInstance(obj)
	if err != nil {
		log.Errorf("ValidateServiceInstance retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.ServiceInstanceCb == nil {
		log.Errorf("No callback registered for serviceInstance object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.serviceInstances[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.ServiceInstanceCb.ServiceInstanceUpdate(collections.serviceInstances[obj.Key], obj)
		if err != nil {
			log.Errorf("ServiceInstanceUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.serviceInstances[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.ServiceInstanceCb.ServiceInstanceCreate(obj)
		if err != nil {
			log.Errorf("ServiceInstanceCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.serviceInstances, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving serviceInstance %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to serviceInstance from collection
func FindServiceInstance(key string) *ServiceInstance {
	obj := collections.serviceInstances[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a serviceInstance object
func DeleteServiceInstance(key string) error {
	obj := collections.serviceInstances[key]
	if obj == nil {
		log.Errorf("serviceInstance %s not found", key)
		return errors.New("serviceInstance not found")
	}

	// Check if we handle this object
	if objCallbackHandler.ServiceInstanceCb == nil {
		log.Errorf("No callback registered for serviceInstance object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.ServiceInstanceCb.ServiceInstanceDelete(obj)
	if err != nil {
		log.Errorf("ServiceInstanceDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting serviceInstance %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.serviceInstances, key)

	return nil
}

func (self *ServiceInstance) GetType() string {
	return "serviceInstance"
}

func (self *ServiceInstance) GetKey() string {
	return self.Key
}

func (self *ServiceInstance) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read serviceInstance object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("serviceInstance", self.Key, self)
}

func (self *ServiceInstance) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write serviceInstance object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("serviceInstance", self.Key, self)
}

func (self *ServiceInstance) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete serviceInstance object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("serviceInstance", self.Key)
}

func restoreServiceInstance() error {
	strList, err := modeldb.ReadAllObj("serviceInstance")
	if err != nil {
		log.Errorf("Error reading serviceInstance list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var serviceInstance ServiceInstance
		err = json.Unmarshal([]byte(objStr), &serviceInstance)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.serviceInstances[serviceInstance.Key] = &serviceInstance
	}

	return nil
}

// Validate a serviceInstance object
func ValidateServiceInstance(obj *ServiceInstance) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.AppName + ":" + obj.ServiceName + ":" + obj.InstanceID
	if obj.Key != keyStr {
		log.Errorf("Expecting ServiceInstance Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}

// LIST REST call
func httpListTenants(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListTenants: %+v", vars)

	list := make([]*Tenant, 0)
	for _, obj := range collections.tenants {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetTenant: %+v", vars)

	key := vars["key"]

	obj := collections.tenants[key]
	if obj == nil {
		log.Errorf("tenant %s not found", key)
		return nil, errors.New("tenant not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetTenant: %+v", vars)

	var obj Tenant
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding tenant create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateTenant(&obj)
	if err != nil {
		log.Errorf("CreateTenant error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteTenant: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteTenant(key)
	if err != nil {
		log.Errorf("DeleteTenant error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a tenant object
func CreateTenant(obj *Tenant) error {
	// Validate parameters
	err := ValidateTenant(obj)
	if err != nil {
		log.Errorf("ValidateTenant retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.TenantCb == nil {
		log.Errorf("No callback registered for tenant object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.tenants[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.TenantCb.TenantUpdate(collections.tenants[obj.Key], obj)
		if err != nil {
			log.Errorf("TenantUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.tenants[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.TenantCb.TenantCreate(obj)
		if err != nil {
			log.Errorf("TenantCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.tenants, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving tenant %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to tenant from collection
func FindTenant(key string) *Tenant {
	obj := collections.tenants[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a tenant object
func DeleteTenant(key string) error {
	obj := collections.tenants[key]
	if obj == nil {
		log.Errorf("tenant %s not found", key)
		return errors.New("tenant not found")
	}

	// Check if we handle this object
	if objCallbackHandler.TenantCb == nil {
		log.Errorf("No callback registered for tenant object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.TenantCb.TenantDelete(obj)
	if err != nil {
		log.Errorf("TenantDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting tenant %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.tenants, key)

	return nil
}

func (self *Tenant) GetType() string {
	return "tenant"
}

func (self *Tenant) GetKey() string {
	return self.Key
}

func (self *Tenant) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read tenant object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("tenant", self.Key, self)
}

func (self *Tenant) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write tenant object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("tenant", self.Key, self)
}

func (self *Tenant) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete tenant object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("tenant", self.Key)
}

func restoreTenant() error {
	strList, err := modeldb.ReadAllObj("tenant")
	if err != nil {
		log.Errorf("Error reading tenant list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var tenant Tenant
		err = json.Unmarshal([]byte(objStr), &tenant)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.tenants[tenant.Key] = &tenant
	}

	return nil
}

// Validate a tenant object
func ValidateTenant(obj *Tenant) error {
	// Validate key is correct
	keyStr := obj.TenantName
	if obj.Key != keyStr {
		log.Errorf("Expecting Tenant Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.DefaultNetwork) > 64 {
		return errors.New("defaultNetwork string too long")
	}

	if obj.SubnetLen < 1 {
		return errors.New("subnetLen Value Out of bound")
	}

	if obj.SubnetLen > 32 {
		return errors.New("subnetLen Value Out of bound")
	}

	subnetPoolMatch := regexp.MustCompile("^([0-9]{1,3}?.[0-9]{1,3}?.[0-9]{1,3}?.[0-9]{1,3}?/[0-9]{1,2}?)$")
	if subnetPoolMatch.MatchString(obj.SubnetPool) == false {
		return errors.New("subnetPool string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	vlansMatch := regexp.MustCompile("^([0-9]{1,4}?-[0-9]{1,4}?)$")
	if vlansMatch.MatchString(obj.Vlans) == false {
		return errors.New("vlans string invalid format")
	}

	vxlansMatch := regexp.MustCompile("^([0-9]{1,8}?-[0-9]{1,8}?)$")
	if vxlansMatch.MatchString(obj.Vxlans) == false {
		return errors.New("vxlans string invalid format")
	}

	return nil
}

// LIST REST call
func httpListVolumes(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListVolumes: %+v", vars)

	list := make([]*Volume, 0)
	for _, obj := range collections.volumes {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolume: %+v", vars)

	key := vars["key"]

	obj := collections.volumes[key]
	if obj == nil {
		log.Errorf("volume %s not found", key)
		return nil, errors.New("volume not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolume: %+v", vars)

	var obj Volume
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding volume create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateVolume(&obj)
	if err != nil {
		log.Errorf("CreateVolume error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteVolume: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteVolume(key)
	if err != nil {
		log.Errorf("DeleteVolume error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a volume object
func CreateVolume(obj *Volume) error {
	// Validate parameters
	err := ValidateVolume(obj)
	if err != nil {
		log.Errorf("ValidateVolume retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeCb == nil {
		log.Errorf("No callback registered for volume object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.volumes[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.VolumeCb.VolumeUpdate(collections.volumes[obj.Key], obj)
		if err != nil {
			log.Errorf("VolumeUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.volumes[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.VolumeCb.VolumeCreate(obj)
		if err != nil {
			log.Errorf("VolumeCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.volumes, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving volume %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to volume from collection
func FindVolume(key string) *Volume {
	obj := collections.volumes[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a volume object
func DeleteVolume(key string) error {
	obj := collections.volumes[key]
	if obj == nil {
		log.Errorf("volume %s not found", key)
		return errors.New("volume not found")
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeCb == nil {
		log.Errorf("No callback registered for volume object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.VolumeCb.VolumeDelete(obj)
	if err != nil {
		log.Errorf("VolumeDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting volume %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.volumes, key)

	return nil
}

func (self *Volume) GetType() string {
	return "volume"
}

func (self *Volume) GetKey() string {
	return self.Key
}

func (self *Volume) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read volume object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("volume", self.Key, self)
}

func (self *Volume) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write volume object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("volume", self.Key, self)
}

func (self *Volume) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete volume object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("volume", self.Key)
}

func restoreVolume() error {
	strList, err := modeldb.ReadAllObj("volume")
	if err != nil {
		log.Errorf("Error reading volume list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var volume Volume
		err = json.Unmarshal([]byte(objStr), &volume)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.volumes[volume.Key] = &volume
	}

	return nil
}

// Validate a volume object
func ValidateVolume(obj *Volume) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.VolumeName
	if obj.Key != keyStr {
		log.Errorf("Expecting Volume Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}

// LIST REST call
func httpListVolumeProfiles(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListVolumeProfiles: %+v", vars)

	list := make([]*VolumeProfile, 0)
	for _, obj := range collections.volumeProfiles {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetVolumeProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolumeProfile: %+v", vars)

	key := vars["key"]

	obj := collections.volumeProfiles[key]
	if obj == nil {
		log.Errorf("volumeProfile %s not found", key)
		return nil, errors.New("volumeProfile not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateVolumeProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolumeProfile: %+v", vars)

	var obj VolumeProfile
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding volumeProfile create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateVolumeProfile(&obj)
	if err != nil {
		log.Errorf("CreateVolumeProfile error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteVolumeProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteVolumeProfile: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteVolumeProfile(key)
	if err != nil {
		log.Errorf("DeleteVolumeProfile error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a volumeProfile object
func CreateVolumeProfile(obj *VolumeProfile) error {
	// Validate parameters
	err := ValidateVolumeProfile(obj)
	if err != nil {
		log.Errorf("ValidateVolumeProfile retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeProfileCb == nil {
		log.Errorf("No callback registered for volumeProfile object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.volumeProfiles[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.VolumeProfileCb.VolumeProfileUpdate(collections.volumeProfiles[obj.Key], obj)
		if err != nil {
			log.Errorf("VolumeProfileUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.volumeProfiles[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.VolumeProfileCb.VolumeProfileCreate(obj)
		if err != nil {
			log.Errorf("VolumeProfileCreate retruned error for: %+v. Err: %v", obj, err)
			delete(collections.volumeProfiles, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving volumeProfile %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to volumeProfile from collection
func FindVolumeProfile(key string) *VolumeProfile {
	obj := collections.volumeProfiles[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a volumeProfile object
func DeleteVolumeProfile(key string) error {
	obj := collections.volumeProfiles[key]
	if obj == nil {
		log.Errorf("volumeProfile %s not found", key)
		return errors.New("volumeProfile not found")
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeProfileCb == nil {
		log.Errorf("No callback registered for volumeProfile object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.VolumeProfileCb.VolumeProfileDelete(obj)
	if err != nil {
		log.Errorf("VolumeProfileDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting volumeProfile %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.volumeProfiles, key)

	return nil
}

func (self *VolumeProfile) GetType() string {
	return "volumeProfile"
}

func (self *VolumeProfile) GetKey() string {
	return self.Key
}

func (self *VolumeProfile) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read volumeProfile object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("volumeProfile", self.Key, self)
}

func (self *VolumeProfile) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write volumeProfile object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("volumeProfile", self.Key, self)
}

func (self *VolumeProfile) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete volumeProfile object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("volumeProfile", self.Key)
}

func restoreVolumeProfile() error {
	strList, err := modeldb.ReadAllObj("volumeProfile")
	if err != nil {
		log.Errorf("Error reading volumeProfile list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var volumeProfile VolumeProfile
		err = json.Unmarshal([]byte(objStr), &volumeProfile)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.volumeProfiles[volumeProfile.Key] = &volumeProfile
	}

	return nil
}

// Validate a volumeProfile object
func ValidateVolumeProfile(obj *VolumeProfile) error {
	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.VolumeProfileName
	if obj.Key != keyStr {
		log.Errorf("Expecting VolumeProfile Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}
