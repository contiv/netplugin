// contivModel.go
// This file is auto generated by modelgen tool
// Do not edit this file manually

package contivModel

import (
	"encoding/json"
	"errors"
	log "github.com/Sirupsen/logrus"
	"github.com/contiv/netplugin/objdb/modeldb"
	"github.com/gorilla/mux"
	"net/http"
	"regexp"
	"sync"
)

type HttpApiFunc func(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error)

type AciGw struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	EnforcePolicies     string `json:"enforcePolicies,omitempty"`     // Enforce security policy
	IncludeCommonTenant string `json:"includeCommonTenant,omitempty"` // Include common tenant when searching for objects
	Name                string `json:"name,omitempty"`                // name of this block(must be 'aciGw')
	NodeBindings        string `json:"nodeBindings,omitempty"`        // List of ACI complete nodes to be bound
	PathBindings        string `json:"pathBindings,omitempty"`        // List of ACI fabric ports connected to cluster
	PhysicalDomain      string `json:"physicalDomain,omitempty"`      // Name of the physical domain

}

type AciGwOper struct {
	NumAppProfiles int `json:"numAppProfiles,omitempty"` //

}

type AciGwInspect struct {
	Config AciGw

	Oper AciGwOper
}

type AppProfile struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	AppProfileName string   `json:"appProfileName,omitempty"` // Application Profile Name
	EndpointGroups []string `json:"endpointGroups,omitempty"`
	TenantName     string   `json:"tenantName,omitempty"` // Tenant Name

	// add link-sets and links
	LinkSets AppProfileLinkSets `json:"link-sets,omitempty"`
	Links    AppProfileLinks    `json:"links,omitempty"`
}

type AppProfileLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`
}

type AppProfileLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type AppProfileInspect struct {
	Config AppProfile
}

type Bgp struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	As         string `json:"as,omitempty"`          // AS id
	Hostname   string `json:"hostname,omitempty"`    // host name
	Neighbor   string `json:"neighbor,omitempty"`    // Bgp  neighbor
	NeighborAs string `json:"neighbor-as,omitempty"` // AS id
	Routerip   string `json:"routerip,omitempty"`    // Bgp router intf ip

}

type BgpOper struct {
	AdminStatus    string   `json:"adminStatus,omitempty"`    // admin status
	NeighborStatus string   `json:"neighborStatus,omitempty"` // neighbor status
	NumRoutes      int      `json:"numRoutes,omitempty"`      // number of routes
	Routes         []string `json:"routes,omitempty"`
}

type BgpInspect struct {
	Config Bgp

	Oper BgpOper
}

type EndpointOper struct {

	// oper object key (present for oper only objects)
	Key string `json:"key,omitempty"`

	ContainerID      string   `json:"containerID,omitempty"`      //
	ContainerName    string   `json:"containerName,omitempty"`    //
	EndpointGroupID  int      `json:"endpointGroupId,omitempty"`  //
	EndpointGroupKey string   `json:"endpointGroupKey,omitempty"` //
	EndpointID       string   `json:"endpointID,omitempty"`       //
	HomingHost       string   `json:"homingHost,omitempty"`       //
	IntfName         string   `json:"intfName,omitempty"`         //
	IpAddress        []string `json:"ipAddress,omitempty"`
	Labels           string   `json:"labels,omitempty"`      //
	MacAddress       string   `json:"macAddress,omitempty"`  //
	Network          string   `json:"network,omitempty"`     //
	ServiceName      string   `json:"serviceName,omitempty"` //
	VirtualPort      string   `json:"virtualPort,omitempty"` //
	VtepIP           string   `json:"vtepIP,omitempty"`      //

}

type EndpointInspect struct {
	Oper EndpointOper
}

type EndpointGroup struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	CfgdTag          string   `json:"cfgdTag,omitempty"` // Configured Group Tag
	ExtContractsGrps []string `json:"extContractsGrps,omitempty"`
	GroupName        string   `json:"groupName,omitempty"`   // Group name
	IpPool           string   `json:"ipPool,omitempty"`      // IP-pool
	NetProfile       string   `json:"netProfile,omitempty"`  // Network profile name
	NetworkName      string   `json:"networkName,omitempty"` // Network
	Policies         []string `json:"policies,omitempty"`
	TenantName       string   `json:"tenantName,omitempty"` // Tenant

	// add link-sets and links
	LinkSets EndpointGroupLinkSets `json:"link-sets,omitempty"`
	Links    EndpointGroupLinks    `json:"links,omitempty"`
}

type EndpointGroupLinkSets struct {
	ExtContractsGrps map[string]modeldb.Link `json:"ExtContractsGrps,omitempty"`

	MatchRules map[string]modeldb.Link `json:"MatchRules,omitempty"`

	Policies map[string]modeldb.Link `json:"Policies,omitempty"`

	Services map[string]modeldb.Link `json:"Services,omitempty"`
}

type EndpointGroupLinks struct {
	AppProfile modeldb.Link `json:"AppProfile,omitempty"`

	NetProfile modeldb.Link `json:"NetProfile,omitempty"`

	Network modeldb.Link `json:"Network,omitempty"`

	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type EndpointGroupOper struct {
	AllocatedIPAddresses string         `json:"allocatedIPAddresses,omitempty"` // allocated IP addresses
	AvailableIPAddresses string         `json:"availableIPAddresses,omitempty"` // Available IP addresses
	Endpoints            []EndpointOper `json:"endpoints,omitempty"`
	ExternalPktTag       int            `json:"externalPktTag,omitempty"` // external packet tag
	GroupTag             string         `json:"groupTag,omitempty"`       // Derived EndpointGroup Tag
	NumEndpoints         int            `json:"numEndpoints,omitempty"`   // number of endpoints
	PktTag               int            `json:"pktTag,omitempty"`         // internal packet tag

}

type EndpointGroupInspect struct {
	Config EndpointGroup

	Oper EndpointGroupOper
}

type ExtContractsGroup struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	Contracts          []string `json:"contracts,omitempty"`
	ContractsGroupName string   `json:"contractsGroupName,omitempty"` // Contracts group name
	ContractsType      string   `json:"contractsType,omitempty"`      // Contracts type
	TenantName         string   `json:"tenantName,omitempty"`         // Tenant name

	// add link-sets and links
	LinkSets ExtContractsGroupLinkSets `json:"link-sets,omitempty"`
}

type ExtContractsGroupLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`
}

type ExtContractsGroupInspect struct {
	Config ExtContractsGroup
}

type Global struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	ArpMode          string `json:"arpMode,omitempty"`          // ARP Mode
	FwdMode          string `json:"fwdMode,omitempty"`          // Forwarding Mode
	Name             string `json:"name,omitempty"`             // name of this block(must be 'global')
	NetworkInfraType string `json:"networkInfraType,omitempty"` // Network infrastructure type
	PvtSubnet        string `json:"pvtSubnet,omitempty"`        // Private Subnet used by host bridge
	Vlans            string `json:"vlans,omitempty"`            // Allowed vlan range
	Vxlans           string `json:"vxlans,omitempty"`           // Allwed vxlan range

}

type GlobalOper struct {
	ClusterMode     string `json:"clusterMode,omitempty"`     //
	DefaultNetwork  string `json:"defaultNetwork,omitempty"`  //
	FreeVXLANsStart int    `json:"freeVXLANsStart,omitempty"` //
	NumNetworks     int    `json:"numNetworks,omitempty"`     //
	VlansInUse      string `json:"vlansInUse,omitempty"`      //
	VxlansInUse     string `json:"vxlansInUse,omitempty"`     //

}

type GlobalInspect struct {
	Config Global

	Oper GlobalOper
}

type Netprofile struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	DSCP        int    `json:"DSCP,omitempty"`        // DSCP
	Bandwidth   string `json:"bandwidth,omitempty"`   // Allocated bandwidth
	Burst       int    `json:"burst,omitempty"`       // burst size
	ProfileName string `json:"profileName,omitempty"` // Network profile name
	TenantName  string `json:"tenantName,omitempty"`  // Tenant name

	// add link-sets and links
	LinkSets NetprofileLinkSets `json:"link-sets,omitempty"`
	Links    NetprofileLinks    `json:"links,omitempty"`
}

type NetprofileLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`
}

type NetprofileLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type NetprofileInspect struct {
	Config Netprofile
}

type Network struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	CfgdTag     string `json:"cfgdTag,omitempty"`     // Configured Network Tag
	Encap       string `json:"encap,omitempty"`       // Encapsulation
	Gateway     string `json:"gateway,omitempty"`     // Gateway
	Ipv6Gateway string `json:"ipv6Gateway,omitempty"` // IPv6Gateway
	Ipv6Subnet  string `json:"ipv6Subnet,omitempty"`  // IPv6Subnet
	NetworkName string `json:"networkName,omitempty"` // Network name
	NwType      string `json:"nwType,omitempty"`      // Network Type
	PktTag      int    `json:"pktTag,omitempty"`      // Vlan/Vxlan Tag
	Subnet      string `json:"subnet,omitempty"`      // Subnet
	TenantName  string `json:"tenantName,omitempty"`  // Tenant Name

	// add link-sets and links
	LinkSets NetworkLinkSets `json:"link-sets,omitempty"`
	Links    NetworkLinks    `json:"links,omitempty"`
}

type NetworkLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`

	Servicelbs map[string]modeldb.Link `json:"Servicelbs,omitempty"`

	Services map[string]modeldb.Link `json:"Services,omitempty"`
}

type NetworkLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type NetworkOper struct {
	AllocatedAddressesCount int            `json:"allocatedAddressesCount,omitempty"` // Vlan/Vxlan Tag
	AllocatedIPAddresses    string         `json:"allocatedIPAddresses,omitempty"`    // allocated IP addresses
	AvailableIPAddresses    string         `json:"availableIPAddresses,omitempty"`    // Available IP addresses
	Endpoints               []EndpointOper `json:"endpoints,omitempty"`
	ExternalPktTag          int            `json:"externalPktTag,omitempty"` // external packet tag
	NetworkTag              string         `json:"networkTag,omitempty"`     // Derived Network Tag
	NumEndpoints            int            `json:"numEndpoints,omitempty"`   // external packet tag
	PktTag                  int            `json:"pktTag,omitempty"`         // internal packet tag

}

type NetworkInspect struct {
	Config Network

	Oper NetworkOper
}

type Policy struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	PolicyName string `json:"policyName,omitempty"` // Policy Name
	TenantName string `json:"tenantName,omitempty"` // Tenant Name

	// add link-sets and links
	LinkSets PolicyLinkSets `json:"link-sets,omitempty"`
	Links    PolicyLinks    `json:"links,omitempty"`
}

type PolicyLinkSets struct {
	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`

	Rules map[string]modeldb.Link `json:"Rules,omitempty"`
}

type PolicyLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type PolicyOper struct {
	Endpoints        []EndpointOper `json:"endpoints,omitempty"`
	NumEndpoints     int            `json:"numEndpoints,omitempty"`     // number of endpoints
	PolicyViolations int            `json:"policyViolations,omitempty"` // number of policyViolations

}

type PolicyInspect struct {
	Config Policy

	Oper PolicyOper
}

type Rule struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	Action            string `json:"action,omitempty"`            // Action
	Direction         string `json:"direction,omitempty"`         // Direction
	FromEndpointGroup string `json:"fromEndpointGroup,omitempty"` // From Endpoint Group
	FromIpAddress     string `json:"fromIpAddress,omitempty"`     // IP Address
	FromNetwork       string `json:"fromNetwork,omitempty"`       // From Network
	PolicyName        string `json:"policyName,omitempty"`        // Policy Name
	Port              int    `json:"port,omitempty"`              // Port No
	Priority          int    `json:"priority,omitempty"`          // Priority
	Protocol          string `json:"protocol,omitempty"`          // Protocol
	RuleID            string `json:"ruleId,omitempty"`            // Rule Id
	TenantName        string `json:"tenantName,omitempty"`        // Tenant Name
	ToEndpointGroup   string `json:"toEndpointGroup,omitempty"`   // To Endpoint Group
	ToIpAddress       string `json:"toIpAddress,omitempty"`       // IP Address
	ToNetwork         string `json:"toNetwork,omitempty"`         // To Network

	// add link-sets and links
	LinkSets RuleLinkSets `json:"link-sets,omitempty"`
	Links    RuleLinks    `json:"links,omitempty"`
}

type RuleLinkSets struct {
	Policies map[string]modeldb.Link `json:"Policies,omitempty"`
}

type RuleLinks struct {
	MatchEndpointGroup modeldb.Link `json:"MatchEndpointGroup,omitempty"`
}

type RuleInspect struct {
	Config Rule
}

type ServiceLB struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	IpAddress   string   `json:"ipAddress,omitempty"`   // Service ip
	NetworkName string   `json:"networkName,omitempty"` // Service network name
	Ports       []string `json:"ports,omitempty"`
	Selectors   []string `json:"selectors,omitempty"`
	ServiceName string   `json:"serviceName,omitempty"` // service name
	TenantName  string   `json:"tenantName,omitempty"`  // Tenant Name

	Links ServiceLBLinks `json:"links,omitempty"`
}

type ServiceLBLinks struct {
	Network modeldb.Link `json:"Network,omitempty"`

	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type ServiceLBOper struct {
	NumProviders int            `json:"numProviders,omitempty"` //  number of provider endpoints for the service
	Providers    []EndpointOper `json:"providers,omitempty"`
	ServiceVip   string         `json:"serviceVip,omitempty"` // allocated IP addresses

}

type ServiceLBInspect struct {
	Config ServiceLB

	Oper ServiceLBOper
}

type Tenant struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	DefaultNetwork string `json:"defaultNetwork,omitempty"` // Network name
	TenantName     string `json:"tenantName,omitempty"`     // Tenant Name

	// add link-sets and links
	LinkSets TenantLinkSets `json:"link-sets,omitempty"`
}

type TenantLinkSets struct {
	AppProfiles map[string]modeldb.Link `json:"AppProfiles,omitempty"`

	EndpointGroups map[string]modeldb.Link `json:"EndpointGroups,omitempty"`

	NetProfiles map[string]modeldb.Link `json:"NetProfiles,omitempty"`

	Networks map[string]modeldb.Link `json:"Networks,omitempty"`

	Policies map[string]modeldb.Link `json:"Policies,omitempty"`

	Servicelbs map[string]modeldb.Link `json:"Servicelbs,omitempty"`

	VolumeProfiles map[string]modeldb.Link `json:"VolumeProfiles,omitempty"`

	Volumes map[string]modeldb.Link `json:"Volumes,omitempty"`
}

type TenantOper struct {
	EndpointGroups   []EndpointGroupOper `json:"endpointGroups,omitempty"`
	Endpoints        []EndpointOper      `json:"endpoints,omitempty"`
	Networks         []NetworkOper       `json:"networks,omitempty"`
	Policies         []PolicyOper        `json:"policies,omitempty"`
	Servicelbs       []ServiceLBOper     `json:"servicelbs,omitempty"`
	TotalAppProfiles int                 `json:"totalAppProfiles,omitempty"` // total number of App-Profiles
	TotalEPGs        int                 `json:"totalEPGs,omitempty"`        // total number of EPGs
	TotalEndpoints   int                 `json:"totalEndpoints,omitempty"`   // total number of endpoints in the tenant
	TotalNetprofiles int                 `json:"totalNetprofiles,omitempty"` // total number of Netprofiles
	TotalNetworks    int                 `json:"totalNetworks,omitempty"`    // total number of networks
	TotalPolicies    int                 `json:"totalPolicies,omitempty"`    // total number of totalPolicies
	TotalServicelbs  int                 `json:"totalServicelbs,omitempty"`  // total number of Servicelbs

}

type TenantInspect struct {
	Config Tenant

	Oper TenantOper
}

type Volume struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	DatastoreType string `json:"datastoreType,omitempty"` //
	MountPoint    string `json:"mountPoint,omitempty"`    //
	PoolName      string `json:"poolName,omitempty"`      //
	Size          string `json:"size,omitempty"`          //
	TenantName    string `json:"tenantName,omitempty"`    // Tenant Name
	VolumeName    string `json:"volumeName,omitempty"`    // Volume Name

	// add link-sets and links
	LinkSets VolumeLinkSets `json:"link-sets,omitempty"`
	Links    VolumeLinks    `json:"links,omitempty"`
}

type VolumeLinkSets struct {
	ServiceInstances map[string]modeldb.Link `json:"ServiceInstances,omitempty"`
}

type VolumeLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type VolumeInspect struct {
	Config Volume
}

type VolumeProfile struct {
	// every object has a key
	Key string `json:"key,omitempty"`

	DatastoreType     string `json:"datastoreType,omitempty"`     //
	MountPoint        string `json:"mountPoint,omitempty"`        //
	PoolName          string `json:"poolName,omitempty"`          //
	Size              string `json:"size,omitempty"`              //
	TenantName        string `json:"tenantName,omitempty"`        // Tenant Name
	VolumeProfileName string `json:"volumeProfileName,omitempty"` // Volume profile Name

	// add link-sets and links
	LinkSets VolumeProfileLinkSets `json:"link-sets,omitempty"`
	Links    VolumeProfileLinks    `json:"links,omitempty"`
}

type VolumeProfileLinkSets struct {
	Services map[string]modeldb.Link `json:"Services,omitempty"`
}

type VolumeProfileLinks struct {
	Tenant modeldb.Link `json:"Tenant,omitempty"`
}

type VolumeProfileInspect struct {
	Config VolumeProfile
}
type Collections struct {
	aciGwMutex sync.Mutex
	aciGws     map[string]*AciGw

	appProfileMutex sync.Mutex
	appProfiles     map[string]*AppProfile

	BgpMutex sync.Mutex
	Bgps     map[string]*Bgp

	endpointGroupMutex sync.Mutex
	endpointGroups     map[string]*EndpointGroup

	extContractsGroupMutex sync.Mutex
	extContractsGroups     map[string]*ExtContractsGroup

	globalMutex sync.Mutex
	globals     map[string]*Global

	netprofileMutex sync.Mutex
	netprofiles     map[string]*Netprofile

	networkMutex sync.Mutex
	networks     map[string]*Network

	policyMutex sync.Mutex
	policys     map[string]*Policy

	ruleMutex sync.Mutex
	rules     map[string]*Rule

	serviceLBMutex sync.Mutex
	serviceLBs     map[string]*ServiceLB

	tenantMutex sync.Mutex
	tenants     map[string]*Tenant

	volumeMutex sync.Mutex
	volumes     map[string]*Volume

	volumeProfileMutex sync.Mutex
	volumeProfiles     map[string]*VolumeProfile
}

var collections Collections

type AciGwCallbacks interface {
	AciGwGetOper(aciGw *AciGwInspect) error

	AciGwCreate(aciGw *AciGw) error
	AciGwUpdate(aciGw, params *AciGw) error
	AciGwDelete(aciGw *AciGw) error
}

type AppProfileCallbacks interface {
	AppProfileCreate(appProfile *AppProfile) error
	AppProfileUpdate(appProfile, params *AppProfile) error
	AppProfileDelete(appProfile *AppProfile) error
}

type BgpCallbacks interface {
	BgpGetOper(Bgp *BgpInspect) error

	BgpCreate(Bgp *Bgp) error
	BgpUpdate(Bgp, params *Bgp) error
	BgpDelete(Bgp *Bgp) error
}

type EndpointCallbacks interface {
	EndpointGetOper(endpoint *EndpointInspect) error
}

type EndpointGroupCallbacks interface {
	EndpointGroupGetOper(endpointGroup *EndpointGroupInspect) error

	EndpointGroupCreate(endpointGroup *EndpointGroup) error
	EndpointGroupUpdate(endpointGroup, params *EndpointGroup) error
	EndpointGroupDelete(endpointGroup *EndpointGroup) error
}

type ExtContractsGroupCallbacks interface {
	ExtContractsGroupCreate(extContractsGroup *ExtContractsGroup) error
	ExtContractsGroupUpdate(extContractsGroup, params *ExtContractsGroup) error
	ExtContractsGroupDelete(extContractsGroup *ExtContractsGroup) error
}

type GlobalCallbacks interface {
	GlobalGetOper(global *GlobalInspect) error

	GlobalCreate(global *Global) error
	GlobalUpdate(global, params *Global) error
	GlobalDelete(global *Global) error
}

type NetprofileCallbacks interface {
	NetprofileCreate(netprofile *Netprofile) error
	NetprofileUpdate(netprofile, params *Netprofile) error
	NetprofileDelete(netprofile *Netprofile) error
}

type NetworkCallbacks interface {
	NetworkGetOper(network *NetworkInspect) error

	NetworkCreate(network *Network) error
	NetworkUpdate(network, params *Network) error
	NetworkDelete(network *Network) error
}

type PolicyCallbacks interface {
	PolicyGetOper(policy *PolicyInspect) error

	PolicyCreate(policy *Policy) error
	PolicyUpdate(policy, params *Policy) error
	PolicyDelete(policy *Policy) error
}

type RuleCallbacks interface {
	RuleCreate(rule *Rule) error
	RuleUpdate(rule, params *Rule) error
	RuleDelete(rule *Rule) error
}

type ServiceLBCallbacks interface {
	ServiceLBGetOper(serviceLB *ServiceLBInspect) error

	ServiceLBCreate(serviceLB *ServiceLB) error
	ServiceLBUpdate(serviceLB, params *ServiceLB) error
	ServiceLBDelete(serviceLB *ServiceLB) error
}

type TenantCallbacks interface {
	TenantGetOper(tenant *TenantInspect) error

	TenantCreate(tenant *Tenant) error
	TenantUpdate(tenant, params *Tenant) error
	TenantDelete(tenant *Tenant) error
}

type VolumeCallbacks interface {
	VolumeCreate(volume *Volume) error
	VolumeUpdate(volume, params *Volume) error
	VolumeDelete(volume *Volume) error
}

type VolumeProfileCallbacks interface {
	VolumeProfileCreate(volumeProfile *VolumeProfile) error
	VolumeProfileUpdate(volumeProfile, params *VolumeProfile) error
	VolumeProfileDelete(volumeProfile *VolumeProfile) error
}

type CallbackHandlers struct {
	AciGwCb             AciGwCallbacks
	AppProfileCb        AppProfileCallbacks
	BgpCb               BgpCallbacks
	EndpointCb          EndpointCallbacks
	EndpointGroupCb     EndpointGroupCallbacks
	ExtContractsGroupCb ExtContractsGroupCallbacks
	GlobalCb            GlobalCallbacks
	NetprofileCb        NetprofileCallbacks
	NetworkCb           NetworkCallbacks
	PolicyCb            PolicyCallbacks
	RuleCb              RuleCallbacks
	ServiceLBCb         ServiceLBCallbacks
	TenantCb            TenantCallbacks
	VolumeCb            VolumeCallbacks
	VolumeProfileCb     VolumeProfileCallbacks
}

var objCallbackHandler CallbackHandlers

func Init() {

	collections.aciGws = make(map[string]*AciGw)

	collections.appProfiles = make(map[string]*AppProfile)

	collections.Bgps = make(map[string]*Bgp)

	collections.endpointGroups = make(map[string]*EndpointGroup)

	collections.extContractsGroups = make(map[string]*ExtContractsGroup)

	collections.globals = make(map[string]*Global)

	collections.netprofiles = make(map[string]*Netprofile)

	collections.networks = make(map[string]*Network)

	collections.policys = make(map[string]*Policy)

	collections.rules = make(map[string]*Rule)

	collections.serviceLBs = make(map[string]*ServiceLB)

	collections.tenants = make(map[string]*Tenant)

	collections.volumes = make(map[string]*Volume)

	collections.volumeProfiles = make(map[string]*VolumeProfile)

	restoreAciGw()
	restoreAppProfile()
	restoreBgp()

	restoreEndpointGroup()
	restoreExtContractsGroup()
	restoreGlobal()
	restoreNetprofile()
	restoreNetwork()
	restorePolicy()
	restoreRule()
	restoreServiceLB()
	restoreTenant()
	restoreVolume()
	restoreVolumeProfile()

}

func GetAciGwCount() int {
	return len(collections.aciGws)
}

func GetAppProfileCount() int {
	return len(collections.appProfiles)
}

func GetBgpCount() int {
	return len(collections.Bgps)
}

func GetEndpointGroupCount() int {
	return len(collections.endpointGroups)
}

func GetExtContractsGroupCount() int {
	return len(collections.extContractsGroups)
}

func GetGlobalCount() int {
	return len(collections.globals)
}

func GetNetprofileCount() int {
	return len(collections.netprofiles)
}

func GetNetworkCount() int {
	return len(collections.networks)
}

func GetPolicyCount() int {
	return len(collections.policys)
}

func GetRuleCount() int {
	return len(collections.rules)
}

func GetServiceLBCount() int {
	return len(collections.serviceLBs)
}

func GetTenantCount() int {
	return len(collections.tenants)
}

func GetVolumeCount() int {
	return len(collections.volumes)
}

func GetVolumeProfileCount() int {
	return len(collections.volumeProfiles)
}

func RegisterAciGwCallbacks(handler AciGwCallbacks) {
	objCallbackHandler.AciGwCb = handler
}

func RegisterAppProfileCallbacks(handler AppProfileCallbacks) {
	objCallbackHandler.AppProfileCb = handler
}

func RegisterBgpCallbacks(handler BgpCallbacks) {
	objCallbackHandler.BgpCb = handler
}

func RegisterEndpointCallbacks(handler EndpointCallbacks) {
	objCallbackHandler.EndpointCb = handler
}

func RegisterEndpointGroupCallbacks(handler EndpointGroupCallbacks) {
	objCallbackHandler.EndpointGroupCb = handler
}

func RegisterExtContractsGroupCallbacks(handler ExtContractsGroupCallbacks) {
	objCallbackHandler.ExtContractsGroupCb = handler
}

func RegisterGlobalCallbacks(handler GlobalCallbacks) {
	objCallbackHandler.GlobalCb = handler
}

func RegisterNetprofileCallbacks(handler NetprofileCallbacks) {
	objCallbackHandler.NetprofileCb = handler
}

func RegisterNetworkCallbacks(handler NetworkCallbacks) {
	objCallbackHandler.NetworkCb = handler
}

func RegisterPolicyCallbacks(handler PolicyCallbacks) {
	objCallbackHandler.PolicyCb = handler
}

func RegisterRuleCallbacks(handler RuleCallbacks) {
	objCallbackHandler.RuleCb = handler
}

func RegisterServiceLBCallbacks(handler ServiceLBCallbacks) {
	objCallbackHandler.ServiceLBCb = handler
}

func RegisterTenantCallbacks(handler TenantCallbacks) {
	objCallbackHandler.TenantCb = handler
}

func RegisterVolumeCallbacks(handler VolumeCallbacks) {
	objCallbackHandler.VolumeCb = handler
}

func RegisterVolumeProfileCallbacks(handler VolumeProfileCallbacks) {
	objCallbackHandler.VolumeProfileCb = handler
}

// Simple Wrapper for http handlers
func makeHttpHandler(handlerFunc HttpApiFunc) http.HandlerFunc {
	// Create a closure and return an anonymous function
	return func(w http.ResponseWriter, r *http.Request) {
		// Call the handler
		resp, err := handlerFunc(w, r, mux.Vars(r))
		if err != nil {
			// Log error
			log.Errorf("Handler for %s %s returned error: %s", r.Method, r.URL, err)

			// Send HTTP response
			http.Error(w, err.Error(), http.StatusInternalServerError)
		} else {
			// Send HTTP response as Json
			err = writeJSON(w, http.StatusOK, resp)
			if err != nil {
				log.Errorf("Error generating json. Err: %v", err)
			}
		}
	}
}

// writeJSON: writes the value v to the http response stream as json with standard
// json encoding.
func writeJSON(w http.ResponseWriter, code int, v interface{}) error {
	// Set content type as json
	w.Header().Set("Content-Type", "application/json")

	// write the HTTP status code
	w.WriteHeader(code)

	// Write the Json output
	return json.NewEncoder(w).Encode(v)
}

// Add all routes for REST handlers
func AddRoutes(router *mux.Router) {
	var route, listRoute, inspectRoute string

	// Register aciGw
	route = "/api/v1/aciGws/{key}/"
	listRoute = "/api/v1/aciGws/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListAciGws))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetAciGw))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateAciGw))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateAciGw))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteAciGw))

	inspectRoute = "/api/v1/inspect/aciGws/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectAciGw))

	// Register appProfile
	route = "/api/v1/appProfiles/{key}/"
	listRoute = "/api/v1/appProfiles/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListAppProfiles))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetAppProfile))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateAppProfile))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateAppProfile))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteAppProfile))

	inspectRoute = "/api/v1/inspect/appProfiles/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectAppProfile))

	// Register Bgp
	route = "/api/v1/Bgps/{key}/"
	listRoute = "/api/v1/Bgps/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListBgps))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetBgp))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateBgp))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateBgp))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteBgp))

	inspectRoute = "/api/v1/inspect/Bgps/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectBgp))

	inspectRoute = "/api/v1/inspect/endpoints/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectEndpoint))

	// Register endpointGroup
	route = "/api/v1/endpointGroups/{key}/"
	listRoute = "/api/v1/endpointGroups/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListEndpointGroups))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetEndpointGroup))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateEndpointGroup))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateEndpointGroup))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteEndpointGroup))

	inspectRoute = "/api/v1/inspect/endpointGroups/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectEndpointGroup))

	// Register extContractsGroup
	route = "/api/v1/extContractsGroups/{key}/"
	listRoute = "/api/v1/extContractsGroups/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListExtContractsGroups))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetExtContractsGroup))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateExtContractsGroup))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateExtContractsGroup))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteExtContractsGroup))

	inspectRoute = "/api/v1/inspect/extContractsGroups/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectExtContractsGroup))

	// Register global
	route = "/api/v1/globals/{key}/"
	listRoute = "/api/v1/globals/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListGlobals))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetGlobal))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateGlobal))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateGlobal))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteGlobal))

	inspectRoute = "/api/v1/inspect/globals/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectGlobal))

	// Register netprofile
	route = "/api/v1/netprofiles/{key}/"
	listRoute = "/api/v1/netprofiles/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListNetprofiles))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetNetprofile))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateNetprofile))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateNetprofile))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteNetprofile))

	inspectRoute = "/api/v1/inspect/netprofiles/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectNetprofile))

	// Register network
	route = "/api/v1/networks/{key}/"
	listRoute = "/api/v1/networks/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListNetworks))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetNetwork))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateNetwork))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateNetwork))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteNetwork))

	inspectRoute = "/api/v1/inspect/networks/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectNetwork))

	// Register policy
	route = "/api/v1/policys/{key}/"
	listRoute = "/api/v1/policys/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListPolicys))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetPolicy))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreatePolicy))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreatePolicy))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeletePolicy))

	inspectRoute = "/api/v1/inspect/policys/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectPolicy))

	// Register rule
	route = "/api/v1/rules/{key}/"
	listRoute = "/api/v1/rules/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListRules))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetRule))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateRule))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateRule))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteRule))

	inspectRoute = "/api/v1/inspect/rules/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectRule))

	// Register serviceLB
	route = "/api/v1/serviceLBs/{key}/"
	listRoute = "/api/v1/serviceLBs/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListServiceLBs))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetServiceLB))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateServiceLB))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateServiceLB))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteServiceLB))

	inspectRoute = "/api/v1/inspect/serviceLBs/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectServiceLB))

	// Register tenant
	route = "/api/v1/tenants/{key}/"
	listRoute = "/api/v1/tenants/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListTenants))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetTenant))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateTenant))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateTenant))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteTenant))

	inspectRoute = "/api/v1/inspect/tenants/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectTenant))

	// Register volume
	route = "/api/v1/volumes/{key}/"
	listRoute = "/api/v1/volumes/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListVolumes))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetVolume))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateVolume))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateVolume))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteVolume))

	inspectRoute = "/api/v1/inspect/volumes/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectVolume))

	// Register volumeProfile
	route = "/api/v1/volumeProfiles/{key}/"
	listRoute = "/api/v1/volumeProfiles/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListVolumeProfiles))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetVolumeProfile))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateVolumeProfile))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateVolumeProfile))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteVolumeProfile))

	inspectRoute = "/api/v1/inspect/volumeProfiles/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspectVolumeProfile))

}

// GET Oper REST call
func httpInspectAciGw(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj AciGwInspect
	log.Debugf("Received httpInspectAciGw: %+v", vars)

	key := vars["key"]

	collections.aciGwMutex.Lock()
	defer collections.aciGwMutex.Unlock()
	objConfig := collections.aciGws[key]
	if objConfig == nil {
		log.Errorf("aciGw %s not found", key)
		return nil, errors.New("aciGw not found")
	}
	obj.Config = *objConfig

	if err := GetOperAciGw(&obj); err != nil {
		log.Errorf("GetAciGw error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a aciGwOper object
func GetOperAciGw(obj *AciGwInspect) error {
	// Check if we handle this object
	if objCallbackHandler.AciGwCb == nil {
		log.Errorf("No callback registered for aciGw object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.AciGwCb.AciGwGetOper(obj)
	if err != nil {
		log.Errorf("AciGwDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListAciGws(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListAciGws: %+v", vars)

	list := make([]*AciGw, 0)
	collections.aciGwMutex.Lock()
	defer collections.aciGwMutex.Unlock()
	for _, obj := range collections.aciGws {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetAciGw(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetAciGw: %+v", vars)

	key := vars["key"]

	collections.aciGwMutex.Lock()
	defer collections.aciGwMutex.Unlock()
	obj := collections.aciGws[key]
	if obj == nil {
		log.Infof("aciGw %s not found", key)
		return nil, errors.New("aciGw not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateAciGw(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetAciGw: %+v", vars)

	var obj AciGw
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding aciGw create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateAciGw(&obj)
	if err != nil {
		log.Errorf("CreateAciGw error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteAciGw(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteAciGw: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteAciGw(key)
	if err != nil {
		log.Errorf("DeleteAciGw error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a aciGw object
func CreateAciGw(obj *AciGw) error {
	// Validate parameters
	err := ValidateAciGw(obj)
	if err != nil {
		log.Errorf("ValidateAciGw retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.AciGwCb == nil {
		log.Errorf("No callback registered for aciGw object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.aciGwMutex.Lock()
	key := collections.aciGws[obj.Key]
	collections.aciGwMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.AciGwCb.AciGwUpdate(collections.aciGws[obj.Key], obj)
		if err != nil {
			log.Errorf("AciGwUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.aciGwMutex.Lock()
		saveObj = collections.aciGws[obj.Key]
		collections.aciGwMutex.Unlock()
	} else {
		// save it in cache
		collections.aciGwMutex.Lock()
		collections.aciGws[obj.Key] = obj
		collections.aciGwMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.AciGwCb.AciGwCreate(obj)
		if err != nil {
			log.Errorf("AciGwCreate retruned error for: %+v. Err: %v", obj, err)
			collections.aciGwMutex.Lock()
			delete(collections.aciGws, obj.Key)
			collections.aciGwMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.aciGwMutex.Lock()
	err = saveObj.Write()
	collections.aciGwMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving aciGw %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to aciGw from collection
func FindAciGw(key string) *AciGw {
	collections.aciGwMutex.Lock()
	defer collections.aciGwMutex.Unlock()

	obj := collections.aciGws[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a aciGw object
func DeleteAciGw(key string) error {
	collections.aciGwMutex.Lock()
	obj := collections.aciGws[key]
	collections.aciGwMutex.Unlock()
	if obj == nil {
		log.Errorf("aciGw %s not found", key)
		return errors.New("aciGw not found")
	}

	// Check if we handle this object
	if objCallbackHandler.AciGwCb == nil {
		log.Errorf("No callback registered for aciGw object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.AciGwCb.AciGwDelete(obj)
	if err != nil {
		log.Errorf("AciGwDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.aciGwMutex.Lock()
	err = obj.Delete()
	collections.aciGwMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting aciGw %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.aciGwMutex.Lock()
	delete(collections.aciGws, key)
	collections.aciGwMutex.Unlock()

	return nil
}

func (self *AciGw) GetType() string {
	return "aciGw"
}

func (self *AciGw) GetKey() string {
	return self.Key
}

func (self *AciGw) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read aciGw object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("aciGw", self.Key, self)
}

func (self *AciGw) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write aciGw object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("aciGw", self.Key, self)
}

func (self *AciGw) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete aciGw object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("aciGw", self.Key)
}

func restoreAciGw() error {
	collections.aciGwMutex.Lock()
	defer collections.aciGwMutex.Unlock()

	strList, err := modeldb.ReadAllObj("aciGw")
	if err != nil {
		log.Errorf("Error reading aciGw list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var aciGw AciGw
		err = json.Unmarshal([]byte(objStr), &aciGw)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.aciGws[aciGw.Key] = &aciGw
	}

	return nil
}

// Validate a aciGw object
func ValidateAciGw(obj *AciGw) error {
	collections.aciGwMutex.Lock()
	defer collections.aciGwMutex.Unlock()

	// Validate key is correct
	keyStr := obj.Name
	if obj.Key != keyStr {
		log.Errorf("Expecting AciGw Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.EnforcePolicies) > 64 {
		return errors.New("enforcePolicies string too long")
	}

	enforcePoliciesMatch := regexp.MustCompile("^(yes|no){1}$")
	if enforcePoliciesMatch.MatchString(obj.EnforcePolicies) == false {
		return errors.New("enforcePolicies string invalid format")
	}

	if len(obj.IncludeCommonTenant) > 64 {
		return errors.New("includeCommonTenant string too long")
	}

	includeCommonTenantMatch := regexp.MustCompile("^(yes|no){1}$")
	if includeCommonTenantMatch.MatchString(obj.IncludeCommonTenant) == false {
		return errors.New("includeCommonTenant string invalid format")
	}

	if len(obj.Name) > 64 {
		return errors.New("name string too long")
	}

	nameMatch := regexp.MustCompile("^(aciGw)$")
	if nameMatch.MatchString(obj.Name) == false {
		return errors.New("name string invalid format")
	}

	if len(obj.NodeBindings) > 2048 {
		return errors.New("nodeBindings string too long")
	}

	nodeBindingsMatch := regexp.MustCompile("^$|^(topology/pod-[0-9]{1,4}/node-[0-9]{1,4}){1}(,topology/pod-[0-9]{1,4}/node-[0-9]{1,4})*$")
	if nodeBindingsMatch.MatchString(obj.NodeBindings) == false {
		return errors.New("nodeBindings string invalid format")
	}

	if len(obj.PathBindings) > 2048 {
		return errors.New("pathBindings string too long")
	}

	pathBindingsMatch := regexp.MustCompile("^$|^(topology/pod-[0-9]{1,4}/paths-[0-9]{1,4}/pathep-\\[eth[0-9]{1,2}/[0-9]{1,2}\\]){1}(,topology/pod-[0-9]{1,4}/paths-[0-9]{1,4}/pathep-\\[eth[0-9]{1,2}/[0-9]{1,2}\\])*$")
	if pathBindingsMatch.MatchString(obj.PathBindings) == false {
		return errors.New("pathBindings string invalid format")
	}

	if len(obj.PhysicalDomain) > 128 {
		return errors.New("physicalDomain string too long")
	}

	physicalDomainMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if physicalDomainMatch.MatchString(obj.PhysicalDomain) == false {
		return errors.New("physicalDomain string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectAppProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj AppProfileInspect
	log.Debugf("Received httpInspectAppProfile: %+v", vars)

	key := vars["key"]

	collections.appProfileMutex.Lock()
	defer collections.appProfileMutex.Unlock()
	objConfig := collections.appProfiles[key]
	if objConfig == nil {
		log.Errorf("appProfile %s not found", key)
		return nil, errors.New("appProfile not found")
	}
	obj.Config = *objConfig

	// Return the obj
	return &obj, nil
}

// LIST REST call
func httpListAppProfiles(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListAppProfiles: %+v", vars)

	list := make([]*AppProfile, 0)
	collections.appProfileMutex.Lock()
	defer collections.appProfileMutex.Unlock()
	for _, obj := range collections.appProfiles {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetAppProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetAppProfile: %+v", vars)

	key := vars["key"]

	collections.appProfileMutex.Lock()
	defer collections.appProfileMutex.Unlock()
	obj := collections.appProfiles[key]
	if obj == nil {
		log.Infof("appProfile %s not found", key)
		return nil, errors.New("appProfile not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateAppProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetAppProfile: %+v", vars)

	var obj AppProfile
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding appProfile create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateAppProfile(&obj)
	if err != nil {
		log.Errorf("CreateAppProfile error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteAppProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteAppProfile: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteAppProfile(key)
	if err != nil {
		log.Errorf("DeleteAppProfile error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a appProfile object
func CreateAppProfile(obj *AppProfile) error {
	// Validate parameters
	err := ValidateAppProfile(obj)
	if err != nil {
		log.Errorf("ValidateAppProfile retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.AppProfileCb == nil {
		log.Errorf("No callback registered for appProfile object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.appProfileMutex.Lock()
	key := collections.appProfiles[obj.Key]
	collections.appProfileMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.AppProfileCb.AppProfileUpdate(collections.appProfiles[obj.Key], obj)
		if err != nil {
			log.Errorf("AppProfileUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.appProfileMutex.Lock()
		saveObj = collections.appProfiles[obj.Key]
		collections.appProfileMutex.Unlock()
	} else {
		// save it in cache
		collections.appProfileMutex.Lock()
		collections.appProfiles[obj.Key] = obj
		collections.appProfileMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.AppProfileCb.AppProfileCreate(obj)
		if err != nil {
			log.Errorf("AppProfileCreate retruned error for: %+v. Err: %v", obj, err)
			collections.appProfileMutex.Lock()
			delete(collections.appProfiles, obj.Key)
			collections.appProfileMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.appProfileMutex.Lock()
	err = saveObj.Write()
	collections.appProfileMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving appProfile %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to appProfile from collection
func FindAppProfile(key string) *AppProfile {
	collections.appProfileMutex.Lock()
	defer collections.appProfileMutex.Unlock()

	obj := collections.appProfiles[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a appProfile object
func DeleteAppProfile(key string) error {
	collections.appProfileMutex.Lock()
	obj := collections.appProfiles[key]
	collections.appProfileMutex.Unlock()
	if obj == nil {
		log.Errorf("appProfile %s not found", key)
		return errors.New("appProfile not found")
	}

	// Check if we handle this object
	if objCallbackHandler.AppProfileCb == nil {
		log.Errorf("No callback registered for appProfile object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.AppProfileCb.AppProfileDelete(obj)
	if err != nil {
		log.Errorf("AppProfileDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.appProfileMutex.Lock()
	err = obj.Delete()
	collections.appProfileMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting appProfile %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.appProfileMutex.Lock()
	delete(collections.appProfiles, key)
	collections.appProfileMutex.Unlock()

	return nil
}

func (self *AppProfile) GetType() string {
	return "appProfile"
}

func (self *AppProfile) GetKey() string {
	return self.Key
}

func (self *AppProfile) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read appProfile object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("appProfile", self.Key, self)
}

func (self *AppProfile) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write appProfile object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("appProfile", self.Key, self)
}

func (self *AppProfile) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete appProfile object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("appProfile", self.Key)
}

func restoreAppProfile() error {
	collections.appProfileMutex.Lock()
	defer collections.appProfileMutex.Unlock()

	strList, err := modeldb.ReadAllObj("appProfile")
	if err != nil {
		log.Errorf("Error reading appProfile list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var appProfile AppProfile
		err = json.Unmarshal([]byte(objStr), &appProfile)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.appProfiles[appProfile.Key] = &appProfile
	}

	return nil
}

// Validate a appProfile object
func ValidateAppProfile(obj *AppProfile) error {
	collections.appProfileMutex.Lock()
	defer collections.appProfileMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.AppProfileName
	if obj.Key != keyStr {
		log.Errorf("Expecting AppProfile Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.AppProfileName) > 64 {
		return errors.New("appProfileName string too long")
	}

	appProfileNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if appProfileNameMatch.MatchString(obj.AppProfileName) == false {
		return errors.New("appProfileName string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectBgp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj BgpInspect
	log.Debugf("Received httpInspectBgp: %+v", vars)

	key := vars["key"]

	collections.BgpMutex.Lock()
	defer collections.BgpMutex.Unlock()
	objConfig := collections.Bgps[key]
	if objConfig == nil {
		log.Errorf("Bgp %s not found", key)
		return nil, errors.New("Bgp not found")
	}
	obj.Config = *objConfig

	if err := GetOperBgp(&obj); err != nil {
		log.Errorf("GetBgp error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a BgpOper object
func GetOperBgp(obj *BgpInspect) error {
	// Check if we handle this object
	if objCallbackHandler.BgpCb == nil {
		log.Errorf("No callback registered for Bgp object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.BgpCb.BgpGetOper(obj)
	if err != nil {
		log.Errorf("BgpDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListBgps(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListBgps: %+v", vars)

	list := make([]*Bgp, 0)
	collections.BgpMutex.Lock()
	defer collections.BgpMutex.Unlock()
	for _, obj := range collections.Bgps {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetBgp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetBgp: %+v", vars)

	key := vars["key"]

	collections.BgpMutex.Lock()
	defer collections.BgpMutex.Unlock()
	obj := collections.Bgps[key]
	if obj == nil {
		log.Infof("Bgp %s not found", key)
		return nil, errors.New("Bgp not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateBgp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetBgp: %+v", vars)

	var obj Bgp
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding Bgp create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateBgp(&obj)
	if err != nil {
		log.Errorf("CreateBgp error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteBgp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteBgp: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteBgp(key)
	if err != nil {
		log.Errorf("DeleteBgp error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a Bgp object
func CreateBgp(obj *Bgp) error {
	// Validate parameters
	err := ValidateBgp(obj)
	if err != nil {
		log.Errorf("ValidateBgp retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.BgpCb == nil {
		log.Errorf("No callback registered for Bgp object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.BgpMutex.Lock()
	key := collections.Bgps[obj.Key]
	collections.BgpMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.BgpCb.BgpUpdate(collections.Bgps[obj.Key], obj)
		if err != nil {
			log.Errorf("BgpUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.BgpMutex.Lock()
		saveObj = collections.Bgps[obj.Key]
		collections.BgpMutex.Unlock()
	} else {
		// save it in cache
		collections.BgpMutex.Lock()
		collections.Bgps[obj.Key] = obj
		collections.BgpMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.BgpCb.BgpCreate(obj)
		if err != nil {
			log.Errorf("BgpCreate retruned error for: %+v. Err: %v", obj, err)
			collections.BgpMutex.Lock()
			delete(collections.Bgps, obj.Key)
			collections.BgpMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.BgpMutex.Lock()
	err = saveObj.Write()
	collections.BgpMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving Bgp %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to Bgp from collection
func FindBgp(key string) *Bgp {
	collections.BgpMutex.Lock()
	defer collections.BgpMutex.Unlock()

	obj := collections.Bgps[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a Bgp object
func DeleteBgp(key string) error {
	collections.BgpMutex.Lock()
	obj := collections.Bgps[key]
	collections.BgpMutex.Unlock()
	if obj == nil {
		log.Errorf("Bgp %s not found", key)
		return errors.New("Bgp not found")
	}

	// Check if we handle this object
	if objCallbackHandler.BgpCb == nil {
		log.Errorf("No callback registered for Bgp object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.BgpCb.BgpDelete(obj)
	if err != nil {
		log.Errorf("BgpDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.BgpMutex.Lock()
	err = obj.Delete()
	collections.BgpMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting Bgp %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.BgpMutex.Lock()
	delete(collections.Bgps, key)
	collections.BgpMutex.Unlock()

	return nil
}

func (self *Bgp) GetType() string {
	return "Bgp"
}

func (self *Bgp) GetKey() string {
	return self.Key
}

func (self *Bgp) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read Bgp object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("Bgp", self.Key, self)
}

func (self *Bgp) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write Bgp object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("Bgp", self.Key, self)
}

func (self *Bgp) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete Bgp object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("Bgp", self.Key)
}

func restoreBgp() error {
	collections.BgpMutex.Lock()
	defer collections.BgpMutex.Unlock()

	strList, err := modeldb.ReadAllObj("Bgp")
	if err != nil {
		log.Errorf("Error reading Bgp list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var Bgp Bgp
		err = json.Unmarshal([]byte(objStr), &Bgp)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.Bgps[Bgp.Key] = &Bgp
	}

	return nil
}

// Validate a Bgp object
func ValidateBgp(obj *Bgp) error {
	collections.BgpMutex.Lock()
	defer collections.BgpMutex.Unlock()

	// Validate key is correct
	keyStr := obj.Hostname
	if obj.Key != keyStr {
		log.Errorf("Expecting Bgp Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.As) > 64 {
		return errors.New("as string too long")
	}

	if len(obj.Hostname) > 256 {
		return errors.New("hostname string too long")
	}

	hostnameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if hostnameMatch.MatchString(obj.Hostname) == false {
		return errors.New("hostname string invalid format")
	}

	if len(obj.Neighbor) > 15 {
		return errors.New("neighbor string too long")
	}

	neighborMatch := regexp.MustCompile("^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})?$")
	if neighborMatch.MatchString(obj.Neighbor) == false {
		return errors.New("neighbor string invalid format")
	}

	if len(obj.NeighborAs) > 64 {
		return errors.New("neighbor-as string too long")
	}

	routeripMatch := regexp.MustCompile("^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})(\\-(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))?/(3[0-1]|2[0-9]|1[0-9]|[1-9])$")
	if routeripMatch.MatchString(obj.Routerip) == false {
		return errors.New("routerip string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectEndpoint(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj EndpointInspect
	log.Debugf("Received httpInspectEndpoint: %+v", vars)

	obj.Oper.Key = vars["key"]

	if err := GetOperEndpoint(&obj); err != nil {
		log.Errorf("GetEndpoint error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a endpointOper object
func GetOperEndpoint(obj *EndpointInspect) error {
	// Check if we handle this object
	if objCallbackHandler.EndpointCb == nil {
		log.Errorf("No callback registered for endpoint object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.EndpointCb.EndpointGetOper(obj)
	if err != nil {
		log.Errorf("EndpointDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// GET Oper REST call
func httpInspectEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj EndpointGroupInspect
	log.Debugf("Received httpInspectEndpointGroup: %+v", vars)

	key := vars["key"]

	collections.endpointGroupMutex.Lock()
	defer collections.endpointGroupMutex.Unlock()
	objConfig := collections.endpointGroups[key]
	if objConfig == nil {
		log.Errorf("endpointGroup %s not found", key)
		return nil, errors.New("endpointGroup not found")
	}
	obj.Config = *objConfig

	if err := GetOperEndpointGroup(&obj); err != nil {
		log.Errorf("GetEndpointGroup error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a endpointGroupOper object
func GetOperEndpointGroup(obj *EndpointGroupInspect) error {
	// Check if we handle this object
	if objCallbackHandler.EndpointGroupCb == nil {
		log.Errorf("No callback registered for endpointGroup object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.EndpointGroupCb.EndpointGroupGetOper(obj)
	if err != nil {
		log.Errorf("EndpointGroupDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListEndpointGroups(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListEndpointGroups: %+v", vars)

	list := make([]*EndpointGroup, 0)
	collections.endpointGroupMutex.Lock()
	defer collections.endpointGroupMutex.Unlock()
	for _, obj := range collections.endpointGroups {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetEndpointGroup: %+v", vars)

	key := vars["key"]

	collections.endpointGroupMutex.Lock()
	defer collections.endpointGroupMutex.Unlock()
	obj := collections.endpointGroups[key]
	if obj == nil {
		log.Infof("endpointGroup %s not found", key)
		return nil, errors.New("endpointGroup not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetEndpointGroup: %+v", vars)

	var obj EndpointGroup
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding endpointGroup create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateEndpointGroup(&obj)
	if err != nil {
		log.Errorf("CreateEndpointGroup error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteEndpointGroup: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteEndpointGroup(key)
	if err != nil {
		log.Errorf("DeleteEndpointGroup error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a endpointGroup object
func CreateEndpointGroup(obj *EndpointGroup) error {
	// Validate parameters
	err := ValidateEndpointGroup(obj)
	if err != nil {
		log.Errorf("ValidateEndpointGroup retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.EndpointGroupCb == nil {
		log.Errorf("No callback registered for endpointGroup object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.endpointGroupMutex.Lock()
	key := collections.endpointGroups[obj.Key]
	collections.endpointGroupMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.EndpointGroupCb.EndpointGroupUpdate(collections.endpointGroups[obj.Key], obj)
		if err != nil {
			log.Errorf("EndpointGroupUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.endpointGroupMutex.Lock()
		saveObj = collections.endpointGroups[obj.Key]
		collections.endpointGroupMutex.Unlock()
	} else {
		// save it in cache
		collections.endpointGroupMutex.Lock()
		collections.endpointGroups[obj.Key] = obj
		collections.endpointGroupMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.EndpointGroupCb.EndpointGroupCreate(obj)
		if err != nil {
			log.Errorf("EndpointGroupCreate retruned error for: %+v. Err: %v", obj, err)
			collections.endpointGroupMutex.Lock()
			delete(collections.endpointGroups, obj.Key)
			collections.endpointGroupMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.endpointGroupMutex.Lock()
	err = saveObj.Write()
	collections.endpointGroupMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving endpointGroup %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to endpointGroup from collection
func FindEndpointGroup(key string) *EndpointGroup {
	collections.endpointGroupMutex.Lock()
	defer collections.endpointGroupMutex.Unlock()

	obj := collections.endpointGroups[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a endpointGroup object
func DeleteEndpointGroup(key string) error {
	collections.endpointGroupMutex.Lock()
	obj := collections.endpointGroups[key]
	collections.endpointGroupMutex.Unlock()
	if obj == nil {
		log.Errorf("endpointGroup %s not found", key)
		return errors.New("endpointGroup not found")
	}

	// Check if we handle this object
	if objCallbackHandler.EndpointGroupCb == nil {
		log.Errorf("No callback registered for endpointGroup object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.EndpointGroupCb.EndpointGroupDelete(obj)
	if err != nil {
		log.Errorf("EndpointGroupDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.endpointGroupMutex.Lock()
	err = obj.Delete()
	collections.endpointGroupMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting endpointGroup %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.endpointGroupMutex.Lock()
	delete(collections.endpointGroups, key)
	collections.endpointGroupMutex.Unlock()

	return nil
}

func (self *EndpointGroup) GetType() string {
	return "endpointGroup"
}

func (self *EndpointGroup) GetKey() string {
	return self.Key
}

func (self *EndpointGroup) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read endpointGroup object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("endpointGroup", self.Key, self)
}

func (self *EndpointGroup) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write endpointGroup object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("endpointGroup", self.Key, self)
}

func (self *EndpointGroup) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete endpointGroup object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("endpointGroup", self.Key)
}

func restoreEndpointGroup() error {
	collections.endpointGroupMutex.Lock()
	defer collections.endpointGroupMutex.Unlock()

	strList, err := modeldb.ReadAllObj("endpointGroup")
	if err != nil {
		log.Errorf("Error reading endpointGroup list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var endpointGroup EndpointGroup
		err = json.Unmarshal([]byte(objStr), &endpointGroup)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.endpointGroups[endpointGroup.Key] = &endpointGroup
	}

	return nil
}

// Validate a endpointGroup object
func ValidateEndpointGroup(obj *EndpointGroup) error {
	collections.endpointGroupMutex.Lock()
	defer collections.endpointGroupMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.GroupName
	if obj.Key != keyStr {
		log.Errorf("Expecting EndpointGroup Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.CfgdTag) > 128 {
		return errors.New("cfgdTag string too long")
	}

	cfgdTagMatch := regexp.MustCompile("^((([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9]))?$")
	if cfgdTagMatch.MatchString(obj.CfgdTag) == false {
		return errors.New("cfgdTag string invalid format")
	}

	if len(obj.GroupName) > 64 {
		return errors.New("groupName string too long")
	}

	groupNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if groupNameMatch.MatchString(obj.GroupName) == false {
		return errors.New("groupName string invalid format")
	}

	ipPoolMatch := regexp.MustCompile("^$|^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})(\\-((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))?$")
	if ipPoolMatch.MatchString(obj.IpPool) == false {
		return errors.New("ipPool string invalid format")
	}

	if len(obj.NetProfile) > 64 {
		return errors.New("netProfile string too long")
	}

	if len(obj.NetworkName) > 64 {
		return errors.New("networkName string too long")
	}

	networkNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if networkNameMatch.MatchString(obj.NetworkName) == false {
		return errors.New("networkName string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectExtContractsGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj ExtContractsGroupInspect
	log.Debugf("Received httpInspectExtContractsGroup: %+v", vars)

	key := vars["key"]

	collections.extContractsGroupMutex.Lock()
	defer collections.extContractsGroupMutex.Unlock()
	objConfig := collections.extContractsGroups[key]
	if objConfig == nil {
		log.Errorf("extContractsGroup %s not found", key)
		return nil, errors.New("extContractsGroup not found")
	}
	obj.Config = *objConfig

	// Return the obj
	return &obj, nil
}

// LIST REST call
func httpListExtContractsGroups(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListExtContractsGroups: %+v", vars)

	list := make([]*ExtContractsGroup, 0)
	collections.extContractsGroupMutex.Lock()
	defer collections.extContractsGroupMutex.Unlock()
	for _, obj := range collections.extContractsGroups {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetExtContractsGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetExtContractsGroup: %+v", vars)

	key := vars["key"]

	collections.extContractsGroupMutex.Lock()
	defer collections.extContractsGroupMutex.Unlock()
	obj := collections.extContractsGroups[key]
	if obj == nil {
		log.Infof("extContractsGroup %s not found", key)
		return nil, errors.New("extContractsGroup not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateExtContractsGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetExtContractsGroup: %+v", vars)

	var obj ExtContractsGroup
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding extContractsGroup create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateExtContractsGroup(&obj)
	if err != nil {
		log.Errorf("CreateExtContractsGroup error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteExtContractsGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteExtContractsGroup: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteExtContractsGroup(key)
	if err != nil {
		log.Errorf("DeleteExtContractsGroup error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a extContractsGroup object
func CreateExtContractsGroup(obj *ExtContractsGroup) error {
	// Validate parameters
	err := ValidateExtContractsGroup(obj)
	if err != nil {
		log.Errorf("ValidateExtContractsGroup retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.ExtContractsGroupCb == nil {
		log.Errorf("No callback registered for extContractsGroup object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.extContractsGroupMutex.Lock()
	key := collections.extContractsGroups[obj.Key]
	collections.extContractsGroupMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.ExtContractsGroupCb.ExtContractsGroupUpdate(collections.extContractsGroups[obj.Key], obj)
		if err != nil {
			log.Errorf("ExtContractsGroupUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.extContractsGroupMutex.Lock()
		saveObj = collections.extContractsGroups[obj.Key]
		collections.extContractsGroupMutex.Unlock()
	} else {
		// save it in cache
		collections.extContractsGroupMutex.Lock()
		collections.extContractsGroups[obj.Key] = obj
		collections.extContractsGroupMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.ExtContractsGroupCb.ExtContractsGroupCreate(obj)
		if err != nil {
			log.Errorf("ExtContractsGroupCreate retruned error for: %+v. Err: %v", obj, err)
			collections.extContractsGroupMutex.Lock()
			delete(collections.extContractsGroups, obj.Key)
			collections.extContractsGroupMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.extContractsGroupMutex.Lock()
	err = saveObj.Write()
	collections.extContractsGroupMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving extContractsGroup %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to extContractsGroup from collection
func FindExtContractsGroup(key string) *ExtContractsGroup {
	collections.extContractsGroupMutex.Lock()
	defer collections.extContractsGroupMutex.Unlock()

	obj := collections.extContractsGroups[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a extContractsGroup object
func DeleteExtContractsGroup(key string) error {
	collections.extContractsGroupMutex.Lock()
	obj := collections.extContractsGroups[key]
	collections.extContractsGroupMutex.Unlock()
	if obj == nil {
		log.Errorf("extContractsGroup %s not found", key)
		return errors.New("extContractsGroup not found")
	}

	// Check if we handle this object
	if objCallbackHandler.ExtContractsGroupCb == nil {
		log.Errorf("No callback registered for extContractsGroup object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.ExtContractsGroupCb.ExtContractsGroupDelete(obj)
	if err != nil {
		log.Errorf("ExtContractsGroupDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.extContractsGroupMutex.Lock()
	err = obj.Delete()
	collections.extContractsGroupMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting extContractsGroup %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.extContractsGroupMutex.Lock()
	delete(collections.extContractsGroups, key)
	collections.extContractsGroupMutex.Unlock()

	return nil
}

func (self *ExtContractsGroup) GetType() string {
	return "extContractsGroup"
}

func (self *ExtContractsGroup) GetKey() string {
	return self.Key
}

func (self *ExtContractsGroup) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read extContractsGroup object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("extContractsGroup", self.Key, self)
}

func (self *ExtContractsGroup) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write extContractsGroup object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("extContractsGroup", self.Key, self)
}

func (self *ExtContractsGroup) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete extContractsGroup object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("extContractsGroup", self.Key)
}

func restoreExtContractsGroup() error {
	collections.extContractsGroupMutex.Lock()
	defer collections.extContractsGroupMutex.Unlock()

	strList, err := modeldb.ReadAllObj("extContractsGroup")
	if err != nil {
		log.Errorf("Error reading extContractsGroup list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var extContractsGroup ExtContractsGroup
		err = json.Unmarshal([]byte(objStr), &extContractsGroup)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.extContractsGroups[extContractsGroup.Key] = &extContractsGroup
	}

	return nil
}

// Validate a extContractsGroup object
func ValidateExtContractsGroup(obj *ExtContractsGroup) error {
	collections.extContractsGroupMutex.Lock()
	defer collections.extContractsGroupMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.ContractsGroupName
	if obj.Key != keyStr {
		log.Errorf("Expecting ExtContractsGroup Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.ContractsGroupName) > 64 {
		return errors.New("contractsGroupName string too long")
	}

	contractsGroupNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if contractsGroupNameMatch.MatchString(obj.ContractsGroupName) == false {
		return errors.New("contractsGroupName string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectGlobal(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj GlobalInspect
	log.Debugf("Received httpInspectGlobal: %+v", vars)

	key := vars["key"]

	collections.globalMutex.Lock()
	defer collections.globalMutex.Unlock()
	objConfig := collections.globals[key]
	if objConfig == nil {
		log.Errorf("global %s not found", key)
		return nil, errors.New("global not found")
	}
	obj.Config = *objConfig

	if err := GetOperGlobal(&obj); err != nil {
		log.Errorf("GetGlobal error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a globalOper object
func GetOperGlobal(obj *GlobalInspect) error {
	// Check if we handle this object
	if objCallbackHandler.GlobalCb == nil {
		log.Errorf("No callback registered for global object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.GlobalCb.GlobalGetOper(obj)
	if err != nil {
		log.Errorf("GlobalDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListGlobals(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListGlobals: %+v", vars)

	list := make([]*Global, 0)
	collections.globalMutex.Lock()
	defer collections.globalMutex.Unlock()
	for _, obj := range collections.globals {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetGlobal(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetGlobal: %+v", vars)

	key := vars["key"]

	collections.globalMutex.Lock()
	defer collections.globalMutex.Unlock()
	obj := collections.globals[key]
	if obj == nil {
		log.Infof("global %s not found", key)
		return nil, errors.New("global not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateGlobal(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetGlobal: %+v", vars)

	var obj Global
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding global create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateGlobal(&obj)
	if err != nil {
		log.Errorf("CreateGlobal error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteGlobal(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteGlobal: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteGlobal(key)
	if err != nil {
		log.Errorf("DeleteGlobal error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a global object
func CreateGlobal(obj *Global) error {
	// Validate parameters
	err := ValidateGlobal(obj)
	if err != nil {
		log.Errorf("ValidateGlobal retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.GlobalCb == nil {
		log.Errorf("No callback registered for global object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.globalMutex.Lock()
	key := collections.globals[obj.Key]
	collections.globalMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.GlobalCb.GlobalUpdate(collections.globals[obj.Key], obj)
		if err != nil {
			log.Errorf("GlobalUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.globalMutex.Lock()
		saveObj = collections.globals[obj.Key]
		collections.globalMutex.Unlock()
	} else {
		// save it in cache
		collections.globalMutex.Lock()
		collections.globals[obj.Key] = obj
		collections.globalMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.GlobalCb.GlobalCreate(obj)
		if err != nil {
			log.Errorf("GlobalCreate retruned error for: %+v. Err: %v", obj, err)
			collections.globalMutex.Lock()
			delete(collections.globals, obj.Key)
			collections.globalMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.globalMutex.Lock()
	err = saveObj.Write()
	collections.globalMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving global %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to global from collection
func FindGlobal(key string) *Global {
	collections.globalMutex.Lock()
	defer collections.globalMutex.Unlock()

	obj := collections.globals[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a global object
func DeleteGlobal(key string) error {
	collections.globalMutex.Lock()
	obj := collections.globals[key]
	collections.globalMutex.Unlock()
	if obj == nil {
		log.Errorf("global %s not found", key)
		return errors.New("global not found")
	}

	// Check if we handle this object
	if objCallbackHandler.GlobalCb == nil {
		log.Errorf("No callback registered for global object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.GlobalCb.GlobalDelete(obj)
	if err != nil {
		log.Errorf("GlobalDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.globalMutex.Lock()
	err = obj.Delete()
	collections.globalMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting global %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.globalMutex.Lock()
	delete(collections.globals, key)
	collections.globalMutex.Unlock()

	return nil
}

func (self *Global) GetType() string {
	return "global"
}

func (self *Global) GetKey() string {
	return self.Key
}

func (self *Global) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read global object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("global", self.Key, self)
}

func (self *Global) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write global object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("global", self.Key, self)
}

func (self *Global) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete global object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("global", self.Key)
}

func restoreGlobal() error {
	collections.globalMutex.Lock()
	defer collections.globalMutex.Unlock()

	strList, err := modeldb.ReadAllObj("global")
	if err != nil {
		log.Errorf("Error reading global list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var global Global
		err = json.Unmarshal([]byte(objStr), &global)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.globals[global.Key] = &global
	}

	return nil
}

// Validate a global object
func ValidateGlobal(obj *Global) error {
	collections.globalMutex.Lock()
	defer collections.globalMutex.Unlock()

	// Validate key is correct
	keyStr := obj.Name
	if obj.Key != keyStr {
		log.Errorf("Expecting Global Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.ArpMode) > 64 {
		return errors.New("arpMode string too long")
	}

	arpModeMatch := regexp.MustCompile("^(proxy|flood)?$")
	if arpModeMatch.MatchString(obj.ArpMode) == false {
		return errors.New("arpMode string invalid format")
	}

	if len(obj.FwdMode) > 64 {
		return errors.New("fwdMode string too long")
	}

	fwdModeMatch := regexp.MustCompile("^(bridge|routing)?$")
	if fwdModeMatch.MatchString(obj.FwdMode) == false {
		return errors.New("fwdMode string invalid format")
	}

	if len(obj.Name) > 64 {
		return errors.New("name string too long")
	}

	nameMatch := regexp.MustCompile("^(global)$")
	if nameMatch.MatchString(obj.Name) == false {
		return errors.New("name string invalid format")
	}

	if len(obj.NetworkInfraType) > 64 {
		return errors.New("networkInfraType string too long")
	}

	networkInfraTypeMatch := regexp.MustCompile("^(aci|aci-opflex|default)?$")
	if networkInfraTypeMatch.MatchString(obj.NetworkInfraType) == false {
		return errors.New("networkInfraType string invalid format")
	}

	pvtSubnetMatch := regexp.MustCompile("^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})/16$")
	if pvtSubnetMatch.MatchString(obj.PvtSubnet) == false {
		return errors.New("pvtSubnet string invalid format")
	}

	vlansMatch := regexp.MustCompile("^([0-9]{1,4}?-[0-9]{1,4}?)$")
	if vlansMatch.MatchString(obj.Vlans) == false {
		return errors.New("vlans string invalid format")
	}

	vxlansMatch := regexp.MustCompile("^([0-9]{1,8}?-[0-9]{1,8}?)$")
	if vxlansMatch.MatchString(obj.Vxlans) == false {
		return errors.New("vxlans string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectNetprofile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj NetprofileInspect
	log.Debugf("Received httpInspectNetprofile: %+v", vars)

	key := vars["key"]

	collections.netprofileMutex.Lock()
	defer collections.netprofileMutex.Unlock()
	objConfig := collections.netprofiles[key]
	if objConfig == nil {
		log.Errorf("netprofile %s not found", key)
		return nil, errors.New("netprofile not found")
	}
	obj.Config = *objConfig

	// Return the obj
	return &obj, nil
}

// LIST REST call
func httpListNetprofiles(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListNetprofiles: %+v", vars)

	list := make([]*Netprofile, 0)
	collections.netprofileMutex.Lock()
	defer collections.netprofileMutex.Unlock()
	for _, obj := range collections.netprofiles {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetNetprofile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetprofile: %+v", vars)

	key := vars["key"]

	collections.netprofileMutex.Lock()
	defer collections.netprofileMutex.Unlock()
	obj := collections.netprofiles[key]
	if obj == nil {
		log.Infof("netprofile %s not found", key)
		return nil, errors.New("netprofile not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateNetprofile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetprofile: %+v", vars)

	var obj Netprofile
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding netprofile create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateNetprofile(&obj)
	if err != nil {
		log.Errorf("CreateNetprofile error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteNetprofile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteNetprofile: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteNetprofile(key)
	if err != nil {
		log.Errorf("DeleteNetprofile error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a netprofile object
func CreateNetprofile(obj *Netprofile) error {
	// Validate parameters
	err := ValidateNetprofile(obj)
	if err != nil {
		log.Errorf("ValidateNetprofile retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.NetprofileCb == nil {
		log.Errorf("No callback registered for netprofile object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.netprofileMutex.Lock()
	key := collections.netprofiles[obj.Key]
	collections.netprofileMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.NetprofileCb.NetprofileUpdate(collections.netprofiles[obj.Key], obj)
		if err != nil {
			log.Errorf("NetprofileUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.netprofileMutex.Lock()
		saveObj = collections.netprofiles[obj.Key]
		collections.netprofileMutex.Unlock()
	} else {
		// save it in cache
		collections.netprofileMutex.Lock()
		collections.netprofiles[obj.Key] = obj
		collections.netprofileMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.NetprofileCb.NetprofileCreate(obj)
		if err != nil {
			log.Errorf("NetprofileCreate retruned error for: %+v. Err: %v", obj, err)
			collections.netprofileMutex.Lock()
			delete(collections.netprofiles, obj.Key)
			collections.netprofileMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.netprofileMutex.Lock()
	err = saveObj.Write()
	collections.netprofileMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving netprofile %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to netprofile from collection
func FindNetprofile(key string) *Netprofile {
	collections.netprofileMutex.Lock()
	defer collections.netprofileMutex.Unlock()

	obj := collections.netprofiles[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a netprofile object
func DeleteNetprofile(key string) error {
	collections.netprofileMutex.Lock()
	obj := collections.netprofiles[key]
	collections.netprofileMutex.Unlock()
	if obj == nil {
		log.Errorf("netprofile %s not found", key)
		return errors.New("netprofile not found")
	}

	// Check if we handle this object
	if objCallbackHandler.NetprofileCb == nil {
		log.Errorf("No callback registered for netprofile object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.NetprofileCb.NetprofileDelete(obj)
	if err != nil {
		log.Errorf("NetprofileDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.netprofileMutex.Lock()
	err = obj.Delete()
	collections.netprofileMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting netprofile %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.netprofileMutex.Lock()
	delete(collections.netprofiles, key)
	collections.netprofileMutex.Unlock()

	return nil
}

func (self *Netprofile) GetType() string {
	return "netprofile"
}

func (self *Netprofile) GetKey() string {
	return self.Key
}

func (self *Netprofile) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read netprofile object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("netprofile", self.Key, self)
}

func (self *Netprofile) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write netprofile object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("netprofile", self.Key, self)
}

func (self *Netprofile) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete netprofile object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("netprofile", self.Key)
}

func restoreNetprofile() error {
	collections.netprofileMutex.Lock()
	defer collections.netprofileMutex.Unlock()

	strList, err := modeldb.ReadAllObj("netprofile")
	if err != nil {
		log.Errorf("Error reading netprofile list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var netprofile Netprofile
		err = json.Unmarshal([]byte(objStr), &netprofile)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.netprofiles[netprofile.Key] = &netprofile
	}

	return nil
}

// Validate a netprofile object
func ValidateNetprofile(obj *Netprofile) error {
	collections.netprofileMutex.Lock()
	defer collections.netprofileMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.ProfileName
	if obj.Key != keyStr {
		log.Errorf("Expecting Netprofile Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if obj.DSCP == 0 {
		obj.DSCP = 0
	}

	if obj.DSCP > 63 {
		return errors.New("DSCP Value Out of bound")
	}

	if len(obj.Bandwidth) > 64 {
		return errors.New("bandwidth string too long")
	}

	bandwidthMatch := regexp.MustCompile("^([1-9][0-9]* (([kmgKMG{1}]bps)|[kmgKMG{1}]|(kb|Kb|Gb|gb|Mb|mb)))?$|^([1-9][0-9]*(((k|m|g|K|G|M)bps)|(k|m|g|K|M|G)|(kb|Kb|Gb|gb|Mb|mb)))?$")
	if bandwidthMatch.MatchString(obj.Bandwidth) == false {
		return errors.New("bandwidth string invalid format")
	}

	if obj.Burst > 10486 {
		return errors.New("burst Value Out of bound")
	}

	if len(obj.ProfileName) > 64 {
		return errors.New("profileName string too long")
	}

	return nil
}

// GET Oper REST call
func httpInspectNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj NetworkInspect
	log.Debugf("Received httpInspectNetwork: %+v", vars)

	key := vars["key"]

	collections.networkMutex.Lock()
	defer collections.networkMutex.Unlock()
	objConfig := collections.networks[key]
	if objConfig == nil {
		log.Errorf("network %s not found", key)
		return nil, errors.New("network not found")
	}
	obj.Config = *objConfig

	if err := GetOperNetwork(&obj); err != nil {
		log.Errorf("GetNetwork error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a networkOper object
func GetOperNetwork(obj *NetworkInspect) error {
	// Check if we handle this object
	if objCallbackHandler.NetworkCb == nil {
		log.Errorf("No callback registered for network object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.NetworkCb.NetworkGetOper(obj)
	if err != nil {
		log.Errorf("NetworkDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListNetworks(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListNetworks: %+v", vars)

	list := make([]*Network, 0)
	collections.networkMutex.Lock()
	defer collections.networkMutex.Unlock()
	for _, obj := range collections.networks {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetwork: %+v", vars)

	key := vars["key"]

	collections.networkMutex.Lock()
	defer collections.networkMutex.Unlock()
	obj := collections.networks[key]
	if obj == nil {
		log.Infof("network %s not found", key)
		return nil, errors.New("network not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetwork: %+v", vars)

	var obj Network
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding network create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateNetwork(&obj)
	if err != nil {
		log.Errorf("CreateNetwork error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteNetwork: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteNetwork(key)
	if err != nil {
		log.Errorf("DeleteNetwork error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a network object
func CreateNetwork(obj *Network) error {
	// Validate parameters
	err := ValidateNetwork(obj)
	if err != nil {
		log.Errorf("ValidateNetwork retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.NetworkCb == nil {
		log.Errorf("No callback registered for network object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.networkMutex.Lock()
	key := collections.networks[obj.Key]
	collections.networkMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.NetworkCb.NetworkUpdate(collections.networks[obj.Key], obj)
		if err != nil {
			log.Errorf("NetworkUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.networkMutex.Lock()
		saveObj = collections.networks[obj.Key]
		collections.networkMutex.Unlock()
	} else {
		// save it in cache
		collections.networkMutex.Lock()
		collections.networks[obj.Key] = obj
		collections.networkMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.NetworkCb.NetworkCreate(obj)
		if err != nil {
			log.Errorf("NetworkCreate retruned error for: %+v. Err: %v", obj, err)
			collections.networkMutex.Lock()
			delete(collections.networks, obj.Key)
			collections.networkMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.networkMutex.Lock()
	err = saveObj.Write()
	collections.networkMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving network %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to network from collection
func FindNetwork(key string) *Network {
	collections.networkMutex.Lock()
	defer collections.networkMutex.Unlock()

	obj := collections.networks[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a network object
func DeleteNetwork(key string) error {
	collections.networkMutex.Lock()
	obj := collections.networks[key]
	collections.networkMutex.Unlock()
	if obj == nil {
		log.Errorf("network %s not found", key)
		return errors.New("network not found")
	}

	// Check if we handle this object
	if objCallbackHandler.NetworkCb == nil {
		log.Errorf("No callback registered for network object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.NetworkCb.NetworkDelete(obj)
	if err != nil {
		log.Errorf("NetworkDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.networkMutex.Lock()
	err = obj.Delete()
	collections.networkMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting network %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.networkMutex.Lock()
	delete(collections.networks, key)
	collections.networkMutex.Unlock()

	return nil
}

func (self *Network) GetType() string {
	return "network"
}

func (self *Network) GetKey() string {
	return self.Key
}

func (self *Network) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read network object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("network", self.Key, self)
}

func (self *Network) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write network object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("network", self.Key, self)
}

func (self *Network) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete network object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("network", self.Key)
}

func restoreNetwork() error {
	collections.networkMutex.Lock()
	defer collections.networkMutex.Unlock()

	strList, err := modeldb.ReadAllObj("network")
	if err != nil {
		log.Errorf("Error reading network list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var network Network
		err = json.Unmarshal([]byte(objStr), &network)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.networks[network.Key] = &network
	}

	return nil
}

// Validate a network object
func ValidateNetwork(obj *Network) error {
	collections.networkMutex.Lock()
	defer collections.networkMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.NetworkName
	if obj.Key != keyStr {
		log.Errorf("Expecting Network Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.CfgdTag) > 128 {
		return errors.New("cfgdTag string too long")
	}

	cfgdTagMatch := regexp.MustCompile("^((([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9]))?$")
	if cfgdTagMatch.MatchString(obj.CfgdTag) == false {
		return errors.New("cfgdTag string invalid format")
	}

	encapMatch := regexp.MustCompile("^(vlan|vxlan)$")
	if encapMatch.MatchString(obj.Encap) == false {
		return errors.New("encap string invalid format")
	}

	gatewayMatch := regexp.MustCompile("^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})?$")
	if gatewayMatch.MatchString(obj.Gateway) == false {
		return errors.New("gateway string invalid format")
	}

	ipv6GatewayMatch := regexp.MustCompile("^(((([0-9]|[a-f]|[A-F]){1,4})((\\:([0-9]|[a-f]|[A-F]){1,4}){7}))|(((([0-9]|[a-f]|[A-F]){1,4}\\:){0,6}|\\:)((\\:([0-9]|[a-f]|[A-F]){1,4}){0,6}|\\:)))?$")
	if ipv6GatewayMatch.MatchString(obj.Ipv6Gateway) == false {
		return errors.New("ipv6Gateway string invalid format")
	}

	ipv6SubnetMatch := regexp.MustCompile("^((((([0-9]|[a-f]|[A-F]){1,4})((\\:([0-9]|[a-f]|[A-F]){1,4}){7}))|(((([0-9]|[a-f]|[A-F]){1,4}\\:){0,6}|\\:)((\\:([0-9]|[a-f]|[A-F]){1,4}){0,6}|\\:)))/(1[0-2][0-7]|[1-9][0-9]|[1-9]))?$")
	if ipv6SubnetMatch.MatchString(obj.Ipv6Subnet) == false {
		return errors.New("ipv6Subnet string invalid format")
	}

	if len(obj.NetworkName) > 64 {
		return errors.New("networkName string too long")
	}

	networkNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if networkNameMatch.MatchString(obj.NetworkName) == false {
		return errors.New("networkName string invalid format")
	}

	if obj.NwType == "" {
		obj.NwType = "data"
	}

	nwTypeMatch := regexp.MustCompile("^(infra|data)$")
	if nwTypeMatch.MatchString(obj.NwType) == false {
		return errors.New("nwType string invalid format")
	}

	if obj.PktTag > 1.6777216e+07 {
		return errors.New("pktTag Value Out of bound")
	}

	subnetMatch := regexp.MustCompile("^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})(\\-((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))?/(3[0-1]|2[0-9]|1[0-9]|[1-9])$")
	if subnetMatch.MatchString(obj.Subnet) == false {
		return errors.New("subnet string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectPolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj PolicyInspect
	log.Debugf("Received httpInspectPolicy: %+v", vars)

	key := vars["key"]

	collections.policyMutex.Lock()
	defer collections.policyMutex.Unlock()
	objConfig := collections.policys[key]
	if objConfig == nil {
		log.Errorf("policy %s not found", key)
		return nil, errors.New("policy not found")
	}
	obj.Config = *objConfig

	if err := GetOperPolicy(&obj); err != nil {
		log.Errorf("GetPolicy error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a policyOper object
func GetOperPolicy(obj *PolicyInspect) error {
	// Check if we handle this object
	if objCallbackHandler.PolicyCb == nil {
		log.Errorf("No callback registered for policy object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.PolicyCb.PolicyGetOper(obj)
	if err != nil {
		log.Errorf("PolicyDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListPolicys(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListPolicys: %+v", vars)

	list := make([]*Policy, 0)
	collections.policyMutex.Lock()
	defer collections.policyMutex.Unlock()
	for _, obj := range collections.policys {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetPolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetPolicy: %+v", vars)

	key := vars["key"]

	collections.policyMutex.Lock()
	defer collections.policyMutex.Unlock()
	obj := collections.policys[key]
	if obj == nil {
		log.Infof("policy %s not found", key)
		return nil, errors.New("policy not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreatePolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetPolicy: %+v", vars)

	var obj Policy
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding policy create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreatePolicy(&obj)
	if err != nil {
		log.Errorf("CreatePolicy error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeletePolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeletePolicy: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeletePolicy(key)
	if err != nil {
		log.Errorf("DeletePolicy error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a policy object
func CreatePolicy(obj *Policy) error {
	// Validate parameters
	err := ValidatePolicy(obj)
	if err != nil {
		log.Errorf("ValidatePolicy retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.PolicyCb == nil {
		log.Errorf("No callback registered for policy object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.policyMutex.Lock()
	key := collections.policys[obj.Key]
	collections.policyMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.PolicyCb.PolicyUpdate(collections.policys[obj.Key], obj)
		if err != nil {
			log.Errorf("PolicyUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.policyMutex.Lock()
		saveObj = collections.policys[obj.Key]
		collections.policyMutex.Unlock()
	} else {
		// save it in cache
		collections.policyMutex.Lock()
		collections.policys[obj.Key] = obj
		collections.policyMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.PolicyCb.PolicyCreate(obj)
		if err != nil {
			log.Errorf("PolicyCreate retruned error for: %+v. Err: %v", obj, err)
			collections.policyMutex.Lock()
			delete(collections.policys, obj.Key)
			collections.policyMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.policyMutex.Lock()
	err = saveObj.Write()
	collections.policyMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving policy %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to policy from collection
func FindPolicy(key string) *Policy {
	collections.policyMutex.Lock()
	defer collections.policyMutex.Unlock()

	obj := collections.policys[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a policy object
func DeletePolicy(key string) error {
	collections.policyMutex.Lock()
	obj := collections.policys[key]
	collections.policyMutex.Unlock()
	if obj == nil {
		log.Errorf("policy %s not found", key)
		return errors.New("policy not found")
	}

	// Check if we handle this object
	if objCallbackHandler.PolicyCb == nil {
		log.Errorf("No callback registered for policy object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.PolicyCb.PolicyDelete(obj)
	if err != nil {
		log.Errorf("PolicyDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.policyMutex.Lock()
	err = obj.Delete()
	collections.policyMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting policy %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.policyMutex.Lock()
	delete(collections.policys, key)
	collections.policyMutex.Unlock()

	return nil
}

func (self *Policy) GetType() string {
	return "policy"
}

func (self *Policy) GetKey() string {
	return self.Key
}

func (self *Policy) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read policy object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("policy", self.Key, self)
}

func (self *Policy) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write policy object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("policy", self.Key, self)
}

func (self *Policy) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete policy object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("policy", self.Key)
}

func restorePolicy() error {
	collections.policyMutex.Lock()
	defer collections.policyMutex.Unlock()

	strList, err := modeldb.ReadAllObj("policy")
	if err != nil {
		log.Errorf("Error reading policy list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var policy Policy
		err = json.Unmarshal([]byte(objStr), &policy)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.policys[policy.Key] = &policy
	}

	return nil
}

// Validate a policy object
func ValidatePolicy(obj *Policy) error {
	collections.policyMutex.Lock()
	defer collections.policyMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.PolicyName
	if obj.Key != keyStr {
		log.Errorf("Expecting Policy Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.PolicyName) > 64 {
		return errors.New("policyName string too long")
	}

	policyNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if policyNameMatch.MatchString(obj.PolicyName) == false {
		return errors.New("policyName string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectRule(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj RuleInspect
	log.Debugf("Received httpInspectRule: %+v", vars)

	key := vars["key"]

	collections.ruleMutex.Lock()
	defer collections.ruleMutex.Unlock()
	objConfig := collections.rules[key]
	if objConfig == nil {
		log.Errorf("rule %s not found", key)
		return nil, errors.New("rule not found")
	}
	obj.Config = *objConfig

	// Return the obj
	return &obj, nil
}

// LIST REST call
func httpListRules(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListRules: %+v", vars)

	list := make([]*Rule, 0)
	collections.ruleMutex.Lock()
	defer collections.ruleMutex.Unlock()
	for _, obj := range collections.rules {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetRule(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetRule: %+v", vars)

	key := vars["key"]

	collections.ruleMutex.Lock()
	defer collections.ruleMutex.Unlock()
	obj := collections.rules[key]
	if obj == nil {
		log.Infof("rule %s not found", key)
		return nil, errors.New("rule not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateRule(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetRule: %+v", vars)

	var obj Rule
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding rule create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateRule(&obj)
	if err != nil {
		log.Errorf("CreateRule error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteRule(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteRule: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteRule(key)
	if err != nil {
		log.Errorf("DeleteRule error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a rule object
func CreateRule(obj *Rule) error {
	// Validate parameters
	err := ValidateRule(obj)
	if err != nil {
		log.Errorf("ValidateRule retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.RuleCb == nil {
		log.Errorf("No callback registered for rule object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.ruleMutex.Lock()
	key := collections.rules[obj.Key]
	collections.ruleMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.RuleCb.RuleUpdate(collections.rules[obj.Key], obj)
		if err != nil {
			log.Errorf("RuleUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.ruleMutex.Lock()
		saveObj = collections.rules[obj.Key]
		collections.ruleMutex.Unlock()
	} else {
		// save it in cache
		collections.ruleMutex.Lock()
		collections.rules[obj.Key] = obj
		collections.ruleMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.RuleCb.RuleCreate(obj)
		if err != nil {
			log.Errorf("RuleCreate retruned error for: %+v. Err: %v", obj, err)
			collections.ruleMutex.Lock()
			delete(collections.rules, obj.Key)
			collections.ruleMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.ruleMutex.Lock()
	err = saveObj.Write()
	collections.ruleMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving rule %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to rule from collection
func FindRule(key string) *Rule {
	collections.ruleMutex.Lock()
	defer collections.ruleMutex.Unlock()

	obj := collections.rules[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a rule object
func DeleteRule(key string) error {
	collections.ruleMutex.Lock()
	obj := collections.rules[key]
	collections.ruleMutex.Unlock()
	if obj == nil {
		log.Errorf("rule %s not found", key)
		return errors.New("rule not found")
	}

	// Check if we handle this object
	if objCallbackHandler.RuleCb == nil {
		log.Errorf("No callback registered for rule object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.RuleCb.RuleDelete(obj)
	if err != nil {
		log.Errorf("RuleDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.ruleMutex.Lock()
	err = obj.Delete()
	collections.ruleMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting rule %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.ruleMutex.Lock()
	delete(collections.rules, key)
	collections.ruleMutex.Unlock()

	return nil
}

func (self *Rule) GetType() string {
	return "rule"
}

func (self *Rule) GetKey() string {
	return self.Key
}

func (self *Rule) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read rule object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("rule", self.Key, self)
}

func (self *Rule) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write rule object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("rule", self.Key, self)
}

func (self *Rule) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete rule object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("rule", self.Key)
}

func restoreRule() error {
	collections.ruleMutex.Lock()
	defer collections.ruleMutex.Unlock()

	strList, err := modeldb.ReadAllObj("rule")
	if err != nil {
		log.Errorf("Error reading rule list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var rule Rule
		err = json.Unmarshal([]byte(objStr), &rule)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.rules[rule.Key] = &rule
	}

	return nil
}

// Validate a rule object
func ValidateRule(obj *Rule) error {
	collections.ruleMutex.Lock()
	defer collections.ruleMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.PolicyName + ":" + obj.RuleID
	if obj.Key != keyStr {
		log.Errorf("Expecting Rule Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	actionMatch := regexp.MustCompile("^(allow|deny)$")
	if actionMatch.MatchString(obj.Action) == false {
		return errors.New("action string invalid format")
	}

	directionMatch := regexp.MustCompile("^(in|out)$")
	if directionMatch.MatchString(obj.Direction) == false {
		return errors.New("direction string invalid format")
	}

	if len(obj.FromEndpointGroup) > 64 {
		return errors.New("fromEndpointGroup string too long")
	}

	fromEndpointGroupMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])?$")
	if fromEndpointGroupMatch.MatchString(obj.FromEndpointGroup) == false {
		return errors.New("fromEndpointGroup string invalid format")
	}

	fromIpAddressMatch := regexp.MustCompile("^(((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})(\\-(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))?(/(3[0-1]|2[0-9]|1[0-9]|[1-9]))?)?$")
	if fromIpAddressMatch.MatchString(obj.FromIpAddress) == false {
		return errors.New("fromIpAddress string invalid format")
	}

	if len(obj.FromNetwork) > 64 {
		return errors.New("fromNetwork string too long")
	}

	fromNetworkMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])?$")
	if fromNetworkMatch.MatchString(obj.FromNetwork) == false {
		return errors.New("fromNetwork string invalid format")
	}

	if len(obj.PolicyName) > 64 {
		return errors.New("policyName string too long")
	}

	policyNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if policyNameMatch.MatchString(obj.PolicyName) == false {
		return errors.New("policyName string invalid format")
	}

	if obj.Port > 65535 {
		return errors.New("port Value Out of bound")
	}

	if obj.Priority == 0 {
		obj.Priority = 1
	}

	if obj.Priority < 1 {
		return errors.New("priority Value Out of bound")
	}

	if obj.Priority > 100 {
		return errors.New("priority Value Out of bound")
	}

	protocolMatch := regexp.MustCompile("^(tcp|udp|icmp||[0-9]{1,3}?)$")
	if protocolMatch.MatchString(obj.Protocol) == false {
		return errors.New("protocol string invalid format")
	}

	if len(obj.RuleID) > 64 {
		return errors.New("ruleId string too long")
	}

	ruleIdMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if ruleIdMatch.MatchString(obj.RuleID) == false {
		return errors.New("ruleId string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	if len(obj.ToEndpointGroup) > 64 {
		return errors.New("toEndpointGroup string too long")
	}

	toEndpointGroupMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])?$")
	if toEndpointGroupMatch.MatchString(obj.ToEndpointGroup) == false {
		return errors.New("toEndpointGroup string invalid format")
	}

	toIpAddressMatch := regexp.MustCompile("^(((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})(\\-(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))?(/(3[0-1]|2[0-9]|1[0-9]|[1-9]))?)?$")
	if toIpAddressMatch.MatchString(obj.ToIpAddress) == false {
		return errors.New("toIpAddress string invalid format")
	}

	if len(obj.ToNetwork) > 64 {
		return errors.New("toNetwork string too long")
	}

	toNetworkMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])?$")
	if toNetworkMatch.MatchString(obj.ToNetwork) == false {
		return errors.New("toNetwork string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectServiceLB(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj ServiceLBInspect
	log.Debugf("Received httpInspectServiceLB: %+v", vars)

	key := vars["key"]

	collections.serviceLBMutex.Lock()
	defer collections.serviceLBMutex.Unlock()
	objConfig := collections.serviceLBs[key]
	if objConfig == nil {
		log.Errorf("serviceLB %s not found", key)
		return nil, errors.New("serviceLB not found")
	}
	obj.Config = *objConfig

	if err := GetOperServiceLB(&obj); err != nil {
		log.Errorf("GetServiceLB error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a serviceLBOper object
func GetOperServiceLB(obj *ServiceLBInspect) error {
	// Check if we handle this object
	if objCallbackHandler.ServiceLBCb == nil {
		log.Errorf("No callback registered for serviceLB object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.ServiceLBCb.ServiceLBGetOper(obj)
	if err != nil {
		log.Errorf("ServiceLBDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListServiceLBs(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListServiceLBs: %+v", vars)

	list := make([]*ServiceLB, 0)
	collections.serviceLBMutex.Lock()
	defer collections.serviceLBMutex.Unlock()
	for _, obj := range collections.serviceLBs {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetServiceLB(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetServiceLB: %+v", vars)

	key := vars["key"]

	collections.serviceLBMutex.Lock()
	defer collections.serviceLBMutex.Unlock()
	obj := collections.serviceLBs[key]
	if obj == nil {
		log.Infof("serviceLB %s not found", key)
		return nil, errors.New("serviceLB not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateServiceLB(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetServiceLB: %+v", vars)

	var obj ServiceLB
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding serviceLB create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateServiceLB(&obj)
	if err != nil {
		log.Errorf("CreateServiceLB error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteServiceLB(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteServiceLB: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteServiceLB(key)
	if err != nil {
		log.Errorf("DeleteServiceLB error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a serviceLB object
func CreateServiceLB(obj *ServiceLB) error {
	// Validate parameters
	err := ValidateServiceLB(obj)
	if err != nil {
		log.Errorf("ValidateServiceLB retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.ServiceLBCb == nil {
		log.Errorf("No callback registered for serviceLB object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.serviceLBMutex.Lock()
	key := collections.serviceLBs[obj.Key]
	collections.serviceLBMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.ServiceLBCb.ServiceLBUpdate(collections.serviceLBs[obj.Key], obj)
		if err != nil {
			log.Errorf("ServiceLBUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.serviceLBMutex.Lock()
		saveObj = collections.serviceLBs[obj.Key]
		collections.serviceLBMutex.Unlock()
	} else {
		// save it in cache
		collections.serviceLBMutex.Lock()
		collections.serviceLBs[obj.Key] = obj
		collections.serviceLBMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.ServiceLBCb.ServiceLBCreate(obj)
		if err != nil {
			log.Errorf("ServiceLBCreate retruned error for: %+v. Err: %v", obj, err)
			collections.serviceLBMutex.Lock()
			delete(collections.serviceLBs, obj.Key)
			collections.serviceLBMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.serviceLBMutex.Lock()
	err = saveObj.Write()
	collections.serviceLBMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving serviceLB %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to serviceLB from collection
func FindServiceLB(key string) *ServiceLB {
	collections.serviceLBMutex.Lock()
	defer collections.serviceLBMutex.Unlock()

	obj := collections.serviceLBs[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a serviceLB object
func DeleteServiceLB(key string) error {
	collections.serviceLBMutex.Lock()
	obj := collections.serviceLBs[key]
	collections.serviceLBMutex.Unlock()
	if obj == nil {
		log.Errorf("serviceLB %s not found", key)
		return errors.New("serviceLB not found")
	}

	// Check if we handle this object
	if objCallbackHandler.ServiceLBCb == nil {
		log.Errorf("No callback registered for serviceLB object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.ServiceLBCb.ServiceLBDelete(obj)
	if err != nil {
		log.Errorf("ServiceLBDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.serviceLBMutex.Lock()
	err = obj.Delete()
	collections.serviceLBMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting serviceLB %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.serviceLBMutex.Lock()
	delete(collections.serviceLBs, key)
	collections.serviceLBMutex.Unlock()

	return nil
}

func (self *ServiceLB) GetType() string {
	return "serviceLB"
}

func (self *ServiceLB) GetKey() string {
	return self.Key
}

func (self *ServiceLB) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read serviceLB object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("serviceLB", self.Key, self)
}

func (self *ServiceLB) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write serviceLB object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("serviceLB", self.Key, self)
}

func (self *ServiceLB) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete serviceLB object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("serviceLB", self.Key)
}

func restoreServiceLB() error {
	collections.serviceLBMutex.Lock()
	defer collections.serviceLBMutex.Unlock()

	strList, err := modeldb.ReadAllObj("serviceLB")
	if err != nil {
		log.Errorf("Error reading serviceLB list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var serviceLB ServiceLB
		err = json.Unmarshal([]byte(objStr), &serviceLB)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.serviceLBs[serviceLB.Key] = &serviceLB
	}

	return nil
}

// Validate a serviceLB object
func ValidateServiceLB(obj *ServiceLB) error {
	collections.serviceLBMutex.Lock()
	defer collections.serviceLBMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.ServiceName
	if obj.Key != keyStr {
		log.Errorf("Expecting ServiceLB Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.IpAddress) > 15 {
		return errors.New("ipAddress string too long")
	}

	ipAddressMatch := regexp.MustCompile("^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})?$")
	if ipAddressMatch.MatchString(obj.IpAddress) == false {
		return errors.New("ipAddress string invalid format")
	}

	if len(obj.NetworkName) > 64 {
		return errors.New("networkName string too long")
	}

	networkNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if networkNameMatch.MatchString(obj.NetworkName) == false {
		return errors.New("networkName string invalid format")
	}

	if len(obj.ServiceName) > 256 {
		return errors.New("serviceName string too long")
	}

	serviceNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if serviceNameMatch.MatchString(obj.ServiceName) == false {
		return errors.New("serviceName string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj TenantInspect
	log.Debugf("Received httpInspectTenant: %+v", vars)

	key := vars["key"]

	collections.tenantMutex.Lock()
	defer collections.tenantMutex.Unlock()
	objConfig := collections.tenants[key]
	if objConfig == nil {
		log.Errorf("tenant %s not found", key)
		return nil, errors.New("tenant not found")
	}
	obj.Config = *objConfig

	if err := GetOperTenant(&obj); err != nil {
		log.Errorf("GetTenant error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return &obj, nil
}

// Get a tenantOper object
func GetOperTenant(obj *TenantInspect) error {
	// Check if we handle this object
	if objCallbackHandler.TenantCb == nil {
		log.Errorf("No callback registered for tenant object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.TenantCb.TenantGetOper(obj)
	if err != nil {
		log.Errorf("TenantDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// LIST REST call
func httpListTenants(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListTenants: %+v", vars)

	list := make([]*Tenant, 0)
	collections.tenantMutex.Lock()
	defer collections.tenantMutex.Unlock()
	for _, obj := range collections.tenants {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetTenant: %+v", vars)

	key := vars["key"]

	collections.tenantMutex.Lock()
	defer collections.tenantMutex.Unlock()
	obj := collections.tenants[key]
	if obj == nil {
		log.Infof("tenant %s not found", key)
		return nil, errors.New("tenant not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetTenant: %+v", vars)

	var obj Tenant
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding tenant create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateTenant(&obj)
	if err != nil {
		log.Errorf("CreateTenant error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteTenant: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteTenant(key)
	if err != nil {
		log.Errorf("DeleteTenant error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a tenant object
func CreateTenant(obj *Tenant) error {
	// Validate parameters
	err := ValidateTenant(obj)
	if err != nil {
		log.Errorf("ValidateTenant retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.TenantCb == nil {
		log.Errorf("No callback registered for tenant object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.tenantMutex.Lock()
	key := collections.tenants[obj.Key]
	collections.tenantMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.TenantCb.TenantUpdate(collections.tenants[obj.Key], obj)
		if err != nil {
			log.Errorf("TenantUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.tenantMutex.Lock()
		saveObj = collections.tenants[obj.Key]
		collections.tenantMutex.Unlock()
	} else {
		// save it in cache
		collections.tenantMutex.Lock()
		collections.tenants[obj.Key] = obj
		collections.tenantMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.TenantCb.TenantCreate(obj)
		if err != nil {
			log.Errorf("TenantCreate retruned error for: %+v. Err: %v", obj, err)
			collections.tenantMutex.Lock()
			delete(collections.tenants, obj.Key)
			collections.tenantMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.tenantMutex.Lock()
	err = saveObj.Write()
	collections.tenantMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving tenant %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to tenant from collection
func FindTenant(key string) *Tenant {
	collections.tenantMutex.Lock()
	defer collections.tenantMutex.Unlock()

	obj := collections.tenants[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a tenant object
func DeleteTenant(key string) error {
	collections.tenantMutex.Lock()
	obj := collections.tenants[key]
	collections.tenantMutex.Unlock()
	if obj == nil {
		log.Errorf("tenant %s not found", key)
		return errors.New("tenant not found")
	}

	// Check if we handle this object
	if objCallbackHandler.TenantCb == nil {
		log.Errorf("No callback registered for tenant object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.TenantCb.TenantDelete(obj)
	if err != nil {
		log.Errorf("TenantDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.tenantMutex.Lock()
	err = obj.Delete()
	collections.tenantMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting tenant %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.tenantMutex.Lock()
	delete(collections.tenants, key)
	collections.tenantMutex.Unlock()

	return nil
}

func (self *Tenant) GetType() string {
	return "tenant"
}

func (self *Tenant) GetKey() string {
	return self.Key
}

func (self *Tenant) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read tenant object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("tenant", self.Key, self)
}

func (self *Tenant) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write tenant object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("tenant", self.Key, self)
}

func (self *Tenant) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete tenant object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("tenant", self.Key)
}

func restoreTenant() error {
	collections.tenantMutex.Lock()
	defer collections.tenantMutex.Unlock()

	strList, err := modeldb.ReadAllObj("tenant")
	if err != nil {
		log.Errorf("Error reading tenant list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var tenant Tenant
		err = json.Unmarshal([]byte(objStr), &tenant)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.tenants[tenant.Key] = &tenant
	}

	return nil
}

// Validate a tenant object
func ValidateTenant(obj *Tenant) error {
	collections.tenantMutex.Lock()
	defer collections.tenantMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName
	if obj.Key != keyStr {
		log.Errorf("Expecting Tenant Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	if len(obj.DefaultNetwork) > 64 {
		return errors.New("defaultNetwork string too long")
	}

	defaultNetworkMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])?$")
	if defaultNetworkMatch.MatchString(obj.DefaultNetwork) == false {
		return errors.New("defaultNetwork string invalid format")
	}

	if len(obj.TenantName) > 64 {
		return errors.New("tenantName string too long")
	}

	tenantNameMatch := regexp.MustCompile("^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$")
	if tenantNameMatch.MatchString(obj.TenantName) == false {
		return errors.New("tenantName string invalid format")
	}

	return nil
}

// GET Oper REST call
func httpInspectVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj VolumeInspect
	log.Debugf("Received httpInspectVolume: %+v", vars)

	key := vars["key"]

	collections.volumeMutex.Lock()
	defer collections.volumeMutex.Unlock()
	objConfig := collections.volumes[key]
	if objConfig == nil {
		log.Errorf("volume %s not found", key)
		return nil, errors.New("volume not found")
	}
	obj.Config = *objConfig

	// Return the obj
	return &obj, nil
}

// LIST REST call
func httpListVolumes(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListVolumes: %+v", vars)

	list := make([]*Volume, 0)
	collections.volumeMutex.Lock()
	defer collections.volumeMutex.Unlock()
	for _, obj := range collections.volumes {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolume: %+v", vars)

	key := vars["key"]

	collections.volumeMutex.Lock()
	defer collections.volumeMutex.Unlock()
	obj := collections.volumes[key]
	if obj == nil {
		log.Infof("volume %s not found", key)
		return nil, errors.New("volume not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolume: %+v", vars)

	var obj Volume
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding volume create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateVolume(&obj)
	if err != nil {
		log.Errorf("CreateVolume error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteVolume: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteVolume(key)
	if err != nil {
		log.Errorf("DeleteVolume error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a volume object
func CreateVolume(obj *Volume) error {
	// Validate parameters
	err := ValidateVolume(obj)
	if err != nil {
		log.Errorf("ValidateVolume retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeCb == nil {
		log.Errorf("No callback registered for volume object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.volumeMutex.Lock()
	key := collections.volumes[obj.Key]
	collections.volumeMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.VolumeCb.VolumeUpdate(collections.volumes[obj.Key], obj)
		if err != nil {
			log.Errorf("VolumeUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.volumeMutex.Lock()
		saveObj = collections.volumes[obj.Key]
		collections.volumeMutex.Unlock()
	} else {
		// save it in cache
		collections.volumeMutex.Lock()
		collections.volumes[obj.Key] = obj
		collections.volumeMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.VolumeCb.VolumeCreate(obj)
		if err != nil {
			log.Errorf("VolumeCreate retruned error for: %+v. Err: %v", obj, err)
			collections.volumeMutex.Lock()
			delete(collections.volumes, obj.Key)
			collections.volumeMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.volumeMutex.Lock()
	err = saveObj.Write()
	collections.volumeMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving volume %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to volume from collection
func FindVolume(key string) *Volume {
	collections.volumeMutex.Lock()
	defer collections.volumeMutex.Unlock()

	obj := collections.volumes[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a volume object
func DeleteVolume(key string) error {
	collections.volumeMutex.Lock()
	obj := collections.volumes[key]
	collections.volumeMutex.Unlock()
	if obj == nil {
		log.Errorf("volume %s not found", key)
		return errors.New("volume not found")
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeCb == nil {
		log.Errorf("No callback registered for volume object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.VolumeCb.VolumeDelete(obj)
	if err != nil {
		log.Errorf("VolumeDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.volumeMutex.Lock()
	err = obj.Delete()
	collections.volumeMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting volume %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.volumeMutex.Lock()
	delete(collections.volumes, key)
	collections.volumeMutex.Unlock()

	return nil
}

func (self *Volume) GetType() string {
	return "volume"
}

func (self *Volume) GetKey() string {
	return self.Key
}

func (self *Volume) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read volume object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("volume", self.Key, self)
}

func (self *Volume) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write volume object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("volume", self.Key, self)
}

func (self *Volume) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete volume object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("volume", self.Key)
}

func restoreVolume() error {
	collections.volumeMutex.Lock()
	defer collections.volumeMutex.Unlock()

	strList, err := modeldb.ReadAllObj("volume")
	if err != nil {
		log.Errorf("Error reading volume list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var volume Volume
		err = json.Unmarshal([]byte(objStr), &volume)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.volumes[volume.Key] = &volume
	}

	return nil
}

// Validate a volume object
func ValidateVolume(obj *Volume) error {
	collections.volumeMutex.Lock()
	defer collections.volumeMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.VolumeName
	if obj.Key != keyStr {
		log.Errorf("Expecting Volume Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}

// GET Oper REST call
func httpInspectVolumeProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj VolumeProfileInspect
	log.Debugf("Received httpInspectVolumeProfile: %+v", vars)

	key := vars["key"]

	collections.volumeProfileMutex.Lock()
	defer collections.volumeProfileMutex.Unlock()
	objConfig := collections.volumeProfiles[key]
	if objConfig == nil {
		log.Errorf("volumeProfile %s not found", key)
		return nil, errors.New("volumeProfile not found")
	}
	obj.Config = *objConfig

	// Return the obj
	return &obj, nil
}

// LIST REST call
func httpListVolumeProfiles(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListVolumeProfiles: %+v", vars)

	list := make([]*VolumeProfile, 0)
	collections.volumeProfileMutex.Lock()
	defer collections.volumeProfileMutex.Unlock()
	for _, obj := range collections.volumeProfiles {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetVolumeProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolumeProfile: %+v", vars)

	key := vars["key"]

	collections.volumeProfileMutex.Lock()
	defer collections.volumeProfileMutex.Unlock()
	obj := collections.volumeProfiles[key]
	if obj == nil {
		log.Infof("volumeProfile %s not found", key)
		return nil, errors.New("volumeProfile not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateVolumeProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolumeProfile: %+v", vars)

	var obj VolumeProfile
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding volumeProfile create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = CreateVolumeProfile(&obj)
	if err != nil {
		log.Errorf("CreateVolumeProfile error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteVolumeProfile(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteVolumeProfile: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := DeleteVolumeProfile(key)
	if err != nil {
		log.Errorf("DeleteVolumeProfile error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a volumeProfile object
func CreateVolumeProfile(obj *VolumeProfile) error {
	// Validate parameters
	err := ValidateVolumeProfile(obj)
	if err != nil {
		log.Errorf("ValidateVolumeProfile retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeProfileCb == nil {
		log.Errorf("No callback registered for volumeProfile object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

	collections.volumeProfileMutex.Lock()
	key := collections.volumeProfiles[obj.Key]
	collections.volumeProfileMutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.VolumeProfileCb.VolumeProfileUpdate(collections.volumeProfiles[obj.Key], obj)
		if err != nil {
			log.Errorf("VolumeProfileUpdate retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
		collections.volumeProfileMutex.Lock()
		saveObj = collections.volumeProfiles[obj.Key]
		collections.volumeProfileMutex.Unlock()
	} else {
		// save it in cache
		collections.volumeProfileMutex.Lock()
		collections.volumeProfiles[obj.Key] = obj
		collections.volumeProfileMutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.VolumeProfileCb.VolumeProfileCreate(obj)
		if err != nil {
			log.Errorf("VolumeProfileCreate retruned error for: %+v. Err: %v", obj, err)
			collections.volumeProfileMutex.Lock()
			delete(collections.volumeProfiles, obj.Key)
			collections.volumeProfileMutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
	collections.volumeProfileMutex.Lock()
	err = saveObj.Write()
	collections.volumeProfileMutex.Unlock()
	if err != nil {
		log.Errorf("Error saving volumeProfile %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to volumeProfile from collection
func FindVolumeProfile(key string) *VolumeProfile {
	collections.volumeProfileMutex.Lock()
	defer collections.volumeProfileMutex.Unlock()

	obj := collections.volumeProfiles[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a volumeProfile object
func DeleteVolumeProfile(key string) error {
	collections.volumeProfileMutex.Lock()
	obj := collections.volumeProfiles[key]
	collections.volumeProfileMutex.Unlock()
	if obj == nil {
		log.Errorf("volumeProfile %s not found", key)
		return errors.New("volumeProfile not found")
	}

	// Check if we handle this object
	if objCallbackHandler.VolumeProfileCb == nil {
		log.Errorf("No callback registered for volumeProfile object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.VolumeProfileCb.VolumeProfileDelete(obj)
	if err != nil {
		log.Errorf("VolumeProfileDelete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	collections.volumeProfileMutex.Lock()
	err = obj.Delete()
	collections.volumeProfileMutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting volumeProfile %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	collections.volumeProfileMutex.Lock()
	delete(collections.volumeProfiles, key)
	collections.volumeProfileMutex.Unlock()

	return nil
}

func (self *VolumeProfile) GetType() string {
	return "volumeProfile"
}

func (self *VolumeProfile) GetKey() string {
	return self.Key
}

func (self *VolumeProfile) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read volumeProfile object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("volumeProfile", self.Key, self)
}

func (self *VolumeProfile) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write volumeProfile object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("volumeProfile", self.Key, self)
}

func (self *VolumeProfile) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete volumeProfile object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("volumeProfile", self.Key)
}

func restoreVolumeProfile() error {
	collections.volumeProfileMutex.Lock()
	defer collections.volumeProfileMutex.Unlock()

	strList, err := modeldb.ReadAllObj("volumeProfile")
	if err != nil {
		log.Errorf("Error reading volumeProfile list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var volumeProfile VolumeProfile
		err = json.Unmarshal([]byte(objStr), &volumeProfile)
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.volumeProfiles[volumeProfile.Key] = &volumeProfile
	}

	return nil
}

// Validate a volumeProfile object
func ValidateVolumeProfile(obj *VolumeProfile) error {
	collections.volumeProfileMutex.Lock()
	defer collections.volumeProfileMutex.Unlock()

	// Validate key is correct
	keyStr := obj.TenantName + ":" + obj.VolumeProfileName
	if obj.Key != keyStr {
		log.Errorf("Expecting VolumeProfile Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field

	return nil
}
